{"version":3,"sources":["../../src/index.ts","../../src/interceptor-manager.ts","../../src/errors/fetch-error.ts","../../src/errors/response-error.ts","../../src/constants.ts","../../src/utils.ts","../../src/queue-manager.ts","../../src/response-parser.ts","../../src/hash.ts","../../src/cache-manager.ts","../../src/config-handler.ts","../../src/retry-handler.ts","../../src/polling-handler.ts","../../src/request-handler.ts","../../src/api-handler.ts"],"sourcesContent":["import { createRequestHandler } from './request-handler';\nimport type {\n  DefaultResponse,\n  FetchResponse,\n  RequestHandlerConfig,\n} from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = DefaultResponse>(\n  url: string,\n  config: RequestHandlerConfig<ResponseData> = {},\n): Promise<FetchResponse<ResponseData>> {\n  return createRequestHandler(config).request<ResponseData>(url);\n}\n\nexport { createApiFetcher } from './api-handler';\n\nexport * from './types';\n","type InterceptorFunction<T> = (object: T) => Promise<T>;\n\n/**\n * Applies interceptors to the object. Interceptors can be a single function or an array of functions.\n *\n * @template T - Type of the object.\n * @template I - Type of interceptors.\n *\n * @param {T} object - The object to process.\n * @param {InterceptorFunction<T> | InterceptorFunction<T>[]} [interceptors] - Interceptor function(s).\n *\n * @returns {Promise<void>} - Nothing as the function is non-idempotent.\n */\nexport async function applyInterceptor<\n  T extends object,\n  I = InterceptorFunction<T> | InterceptorFunction<T>[],\n>(object: T, interceptors?: I): Promise<void> {\n  if (!interceptors) {\n    return;\n  }\n\n  if (typeof interceptors === 'function') {\n    const value = await interceptors(object);\n\n    if (value) {\n      Object.assign(object, value);\n    }\n  } else if (Array.isArray(interceptors)) {\n    for (const interceptor of interceptors) {\n      const value = await interceptor(object);\n\n      if (value) {\n        Object.assign(object, value);\n      }\n    }\n  }\n}\n","import type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\n/**\n * This is a base error class\n */\nexport class FetchError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends Error {\n  status: number;\n  statusText: string;\n  config: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>;\n\n  constructor(\n    message: string,\n    public request: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    >,\n    public response: FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    > | null,\n  ) {\n    super(message);\n\n    this.name = 'FetchError';\n    this.status = response?.status || 0;\n    this.statusText = response?.statusText || '';\n    this.config = request;\n  }\n}\n","import { FetchError } from './fetch-error';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\nexport class ResponseError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends FetchError<ResponseData, QueryParams, PathParams, RequestBody> {\n  constructor(\n    message: string,\n    request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n  ) {\n    super(message, request, response);\n\n    this.name = 'ResponseError';\n  }\n}\n","export const APPLICATION_CONTENT_TYPE = 'application/';\n\nexport const APPLICATION_JSON = APPLICATION_CONTENT_TYPE + 'json';\nexport const CHARSET_UTF_8 = 'charset=utf-8';\nexport const CONTENT_TYPE = 'Content-Type';\n\nexport const UNDEFINED = 'undefined';\nexport const OBJECT = 'object';\nexport const STRING = 'string';\nexport const FUNCTION = 'function';\n\nexport const ABORT_ERROR = 'AbortError';\nexport const TIMEOUT_ERROR = 'TimeoutError';\nexport const CANCELLED_ERROR = 'CanceledError';\n\nexport const GET = 'GET';\nexport const HEAD = 'HEAD';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { FUNCTION, OBJECT, STRING, UNDEFINED } from './constants';\nimport type {\n  DefaultUrlParams,\n  HeadersObject,\n  QueryParams,\n  UrlPathParams,\n} from './types';\n\n// Prevent stack overflow with recursion depth limit\nconst MAX_DEPTH = 10;\n\nconst dangerousProps = ['__proto__', 'constructor', 'prototype'];\n\nexport function isSearchParams(data: unknown): boolean {\n  return data instanceof URLSearchParams;\n}\n\n/**\n * Determines if a value is a non-null object.\n *\n * @param {any} value - The value to check.\n * @returns {boolean} - True if the value is a non-null object.\n */\nexport function isObject(value: any): value is Record<string, any> {\n  return value !== null && typeof value === OBJECT;\n}\n\n/**\n * Shallowly serializes an object by converting its key-value pairs into a string representation.\n * This function does not recursively serialize nested objects.\n *\n * @param obj - The object to serialize.\n * @returns A string representation of the object's top-level properties.\n */\nexport function shallowSerialize(obj: Record<string, any>): string {\n  let result = '';\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result += key + ':' + obj[key];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Removes properties that could lead to prototype pollution from an object.\n *\n * This function creates a shallow copy of the input object with dangerous\n * properties like '__proto__', 'constructor', and 'prototype' removed.\n *\n * @param obj - The object to sanitize\n * @returns A new object without dangerous properties\n */\nexport function sanitizeObject<T extends Record<string, any>>(\n  obj: T,\n): Partial<T> {\n  if (!obj || typeof obj !== OBJECT || Array.isArray(obj)) {\n    return obj;\n  }\n\n  const safeObj = { ...obj };\n\n  dangerousProps.forEach((prop) => {\n    delete safeObj[prop];\n  });\n\n  return safeObj;\n}\n\n/**\n * Sorts the keys of an object and returns a new object with sorted keys.\n *\n * This function is optimized for performance by minimizing the number of object operations\n * and using a single pass to create the sorted object.\n *\n * @param {Object} obj - The object to be sorted by keys.\n * @returns {Object} - A new object with keys sorted in ascending order.\n */\nexport function sortObject(obj: Record<string, any>): object {\n  const sortedObj = {} as Record<string, string>;\n  const keys = Object.keys(obj);\n\n  keys.sort();\n\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n\n    // Skip dangerous property names to prevent prototype pollution\n    if (dangerousProps.includes(key)) {\n      continue;\n    }\n\n    sortedObj[key] = obj[key];\n  }\n\n  return sortedObj;\n}\n\n/**\n * Appends a query string to a URL, ensuring proper handling of existing query parameters.\n *\n * @param baseUrl - The base URL to which the query string will be appended.\n * @param queryString - The encoded query string to append.\n * @returns The URL with the appended query string, or the original URL if no query string is provided.\n */\nfunction appendQueryStringToUrl(baseUrl: string, queryString: string): string {\n  if (!queryString) {\n    return baseUrl;\n  }\n\n  return baseUrl.includes('?')\n    ? `${baseUrl}&${queryString}`\n    : `${baseUrl}?${queryString}`;\n}\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (isSearchParams(params)) {\n    const encodedQueryString = params.toString();\n\n    return appendQueryStringToUrl(url, encodedQueryString);\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s: string[] = [];\n  const encode = encodeURIComponent;\n  const add = (k: string, v: any) => {\n    v = typeof v === FUNCTION ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encode(k) + '=' + encode(v);\n  };\n\n  const buildParams = (prefix: string, obj: any, depth = 0) => {\n    // Stop recursion if maximum depth is reached\n    if (depth >= MAX_DEPTH) {\n      return s;\n    }\n\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix + '[' + (typeof obj[i] === OBJECT && obj[i] ? i : '') + ']',\n            obj[i],\n            depth + 1,\n          );\n        }\n      } else if (isObject(obj)) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key], depth + 1);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key], depth + 1);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  // This is for compatibility with server frameworks that expect the literal notation\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return appendQueryStringToUrl(url, encodedQueryString);\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams || url.indexOf(':') === -1) {\n    return url;\n  }\n\n  // Use a single RegExp and avoid unnecessary casts and function calls\n  // Precompute keys for faster lookup\n  const params = urlPathParams as DefaultUrlParams;\n\n  // Use a replacer function that avoids extra work\n  return url.replace(/:([a-zA-Z0-9_]+)/g, (match, key) => {\n    // Use hasOwnProperty for strict key existence check\n    if (Object.prototype.hasOwnProperty.call(params, key)) {\n      const value = params[key];\n\n      // Only replace if value is not undefined or null\n      if (value !== undefined && value !== null) {\n        return encodeURIComponent(String(value));\n      }\n    }\n\n    return match;\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  const t = typeof value;\n\n  if (t === UNDEFINED || value === null) {\n    return false;\n  }\n\n  if (t === STRING || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (\n    typeof globalThis !== UNDEFINED &&\n    typeof globalThis.Buffer !== UNDEFINED &&\n    globalThis.Buffer.isBuffer(value)\n  ) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  if (isObject(value)) {\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` (plain object)\n    if (proto === Object.prototype) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === FUNCTION) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n\n/**\n * Recursively flattens the data object if it meets specific criteria.\n *\n * The method checks if the provided `data` is an object with exactly one property named `data`.\n * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n *\n * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n */\nexport function flattenData(data: any, depth = 0): any {\n  if (depth >= MAX_DEPTH) {\n    return data;\n  }\n\n  if (\n    data &&\n    isObject(data) &&\n    typeof data.data !== UNDEFINED &&\n    Object.keys(data).length === 1\n  ) {\n    return flattenData(data.data, depth + 1);\n  }\n\n  return data;\n}\n\n/**\n * Processes headers and returns them as a normalized object.\n *\n * Handles both `Headers` instances and plain objects. Normalizes header keys to lowercase\n * as per RFC 2616 section 4.2.\n *\n * @param headers - The headers to process. Can be an instance of `Headers`, a plain object,\n *                   or `null`. If `null`, an empty object is returned.\n * @returns {HeadersObject} - A normalized headers object with lowercase keys.\n */\nexport function processHeaders(\n  headers?: (HeadersObject & HeadersInit) | null | Headers,\n): HeadersObject {\n  if (!headers) {\n    return {};\n  }\n\n  const headersObject: HeadersObject = {};\n\n  // Handle Headers object with entries() method\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n  } else if (isObject(headers)) {\n    // Handle plain object\n    for (const [key, value] of Object.entries(headers)) {\n      // Normalize keys to lowercase as per RFC 2616 4.2\n      // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n      headersObject[key.toLowerCase()] = value;\n    }\n  }\n\n  return headersObject;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ABORT_ERROR, TIMEOUT_ERROR } from './constants';\nimport type { QueueItem } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: Map<string, QueueItem> = new Map();\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {string | null} key - Unique key for the request (e.g. cache key).\n * @param {string} url - The request URL (for error messages/timeouts).\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} isTimeoutEnabled - Whether timeout is enabled.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function queueRequest(\n  key: string | null,\n  url: string,\n  timeout: number | undefined,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  isTimeoutEnabled: boolean = true,\n): Promise<AbortController> {\n  if (!key) {\n    return new AbortController();\n  }\n\n  const now = Date.now();\n  const item = queue.get(key);\n\n  if (item) {\n    const prevIsCancellable = item[3];\n    const previousController = item[0];\n    const timeoutId = item[1];\n\n    // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n    if (!prevIsCancellable && now - item[2] < dedupeTime) {\n      return previousController;\n    }\n\n    // If the request is too old, remove it and proceed to add a new one\n    // Abort previous request, if applicable, and continue as usual\n    if (prevIsCancellable) {\n      previousController.abort(\n        new DOMException('Aborted due to new request', ABORT_ERROR),\n      );\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(key);\n  }\n\n  const controller = new AbortController();\n\n  const timeoutId = isTimeoutEnabled\n    ? setTimeout(() => {\n        const error = new DOMException(\n          `${url} aborted due to timeout`,\n          TIMEOUT_ERROR,\n        );\n\n        removeRequestFromQueue(key, error);\n      }, timeout)\n    : null;\n\n  queue.set(key, [controller, timeoutId, now, isCancellable]);\n\n  return controller;\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param key - Unique key for the request.\n * @param {boolean} error - Error payload so to force the request to abort.\n */\nexport async function removeRequestFromQueue(\n  key: string | null,\n  error: DOMException | null | string = null,\n): Promise<void> {\n  // If the key is not in the queue, there's nothing to remove\n  if (!key) {\n    return;\n  }\n\n  const item = queue.get(key);\n\n  if (item) {\n    const controller = item[0];\n    const timeoutId = item[1];\n\n    // If the request is not yet aborted, abort it with the provided error\n    if (error && !controller.signal.aborted) {\n      controller.abort(error);\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(key);\n  }\n}\n\n/**\n * Gets the AbortController for a request key.\n *\n * @param key - Unique key for the request.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  key: string,\n): Promise<AbortController | undefined> {\n  const item = queue.get(key);\n\n  return item?.[0];\n}\n\n/**\n * Adds helpers for in-flight promise deduplication.\n *\n * @param key - Unique key for the request.\n * @param promise - The promise to store.\n */\nexport function setInFlightPromise(key: string, promise: Promise<any>) {\n  const item = queue.get(key);\n  if (item) {\n    // store the promise at index 4\n    item[4] = promise;\n\n    queue.set(key, item);\n  }\n}\n\n/**\n * Retrieves the in-flight promise for a request key if it exists and is within the dedupeTime interval.\n *\n * @param key - Unique key for the request.\n * @param dedupeTime - Deduplication time in milliseconds.\n * @returns {Promise<unknown> | null} - The in-flight promise or null.\n */\nexport function getInFlightPromise(\n  key: string,\n  dedupeTime: number,\n): Promise<unknown> | null {\n  const item = queue.get(key);\n\n  if (item && item[4] && Date.now() - item[2] < dedupeTime) {\n    return item[4];\n  }\n\n  return null;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  APPLICATION_CONTENT_TYPE,\n  APPLICATION_JSON,\n  CONTENT_TYPE,\n  OBJECT,\n} from './constants';\nimport {\n  DefaultResponse,\n  FetchResponse,\n  RequestConfig,\n  ResponseError,\n  DefaultParams,\n  DefaultUrlParams,\n  DefaultPayload,\n} from './types';\nimport { flattenData, processHeaders } from './utils';\n\n/**\n * Parses the response data based on the Content-Type header.\n *\n * @param response - The Response object to parse.\n * @returns A Promise that resolves to the parsed data.\n */\nexport async function parseResponseData<ResponseData = DefaultResponse>(\n  response: FetchResponse<ResponseData>,\n): Promise<any> {\n  // Bail early for HEAD requests or status codes, or any requests that never have a body\n  if (!response?.body) {\n    return null;\n  }\n\n  // Get the content-type header once\n  let contentType = (response as Response).headers?.get(CONTENT_TYPE);\n\n  if (contentType) {\n    // Lowercase and trim for consistent matching\n    contentType = contentType.toLowerCase().trim();\n  } else {\n    contentType = '';\n  }\n\n  // Split for mime type without charset\n  const mimeType = contentType.split(';', 1)[0];\n\n  let data;\n\n  try {\n    if (mimeType.includes(APPLICATION_JSON) || mimeType.includes('+json')) {\n      data = await response.json(); // Parse JSON response\n    } else if (mimeType.includes('multipart/form-data')) {\n      data = await response.formData(); // Parse as FormData\n    } else if (mimeType.includes(APPLICATION_CONTENT_TYPE + 'octet-stream')) {\n      data = await response.blob(); // Parse as blob\n    } else if (\n      mimeType.includes(APPLICATION_CONTENT_TYPE + 'x-www-form-urlencoded')\n    ) {\n      data = await response.formData(); // Handle URL-encoded forms\n    } else if (mimeType.startsWith('text/')) {\n      data = await response.text(); // Parse as text\n    } else {\n      try {\n        const responseClone = response.clone();\n\n        // Handle edge case of no content type being provided... We assume JSON here.\n        data = await responseClone.json();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_e) {\n        // Handle streams\n        data = await response.text();\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_error) {\n    // Parsing failed, fallback to null\n    data = null;\n  }\n\n  return data;\n}\n\n/**\n * Prepare response object with additional information.\n *\n * @param Response. It may be \"null\" in case of request being aborted.\n * @param {RequestConfig} requestConfig - Request config\n * @param error - whether the response is erroneous\n * @returns {FetchResponse<ResponseData>} Response data\n */\nexport const prepareResponse = <\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n>(\n  response: FetchResponse<\n    ResponseData,\n    RequestBody,\n    QueryParams,\n    PathParams\n  > | null,\n  requestConfig: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  >,\n  error: ResponseError<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > | null = null,\n): FetchResponse<ResponseData, RequestBody, QueryParams, PathParams> => {\n  const defaultResponse = requestConfig.defaultResponse ?? null;\n\n  // This may happen when request is cancelled.\n  if (!response) {\n    return {\n      ok: false,\n      // Enhance the response with extra information\n      error,\n      data: defaultResponse,\n      headers: null,\n      config: requestConfig,\n    } as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }\n\n  let data = response.data;\n\n  // Set the default response if the provided data is an empty object\n  if (\n    data === undefined ||\n    data === null ||\n    (typeof data === OBJECT && Object.keys(data).length === 0)\n  ) {\n    data = defaultResponse;\n  }\n\n  if (requestConfig.flattenResponse) {\n    response.data = flattenData(data);\n  }\n\n  // If it's a custom fetcher, and it does not return any Response instance, it may have its own internal handler\n  if (!(response instanceof Response)) {\n    return response;\n  }\n\n  // Native fetch Response extended by extra information\n  return {\n    body: response.body,\n    bodyUsed: response.bodyUsed,\n    ok: response.ok,\n    redirected: response.redirected,\n    type: response.type,\n    url: response.url,\n    status: response.status,\n    statusText: response.statusText,\n\n    // Convert methods to use arrow functions to preserve correct return types\n    blob: () => response.blob(),\n    json: () => response.json(),\n    text: () => response.text(),\n    clone: () => response.clone(),\n    arrayBuffer: () => response.arrayBuffer(),\n    formData: () => response.formData(),\n    bytes: () => response.bytes(),\n\n    // Enhance the response with extra information\n    error,\n    data,\n    headers: processHeaders(response.headers),\n    config: requestConfig,\n  };\n};\n","const PRIME_MULTIPLIER = 31;\n\n/**\n * Computes a hash value for a given string using the variant of djb2 hash function.\n * This hash function is non-cryptographic and designed for speed.\n * @author Daniel J. Bernstein (of djb2)\n *\n * @param str Input string to hash\n * @returns {string} Hash\n */\nexport function hash(str: string): string {\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash * PRIME_MULTIPLIER + char) | 0;\n  }\n\n  return String(hash);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hash } from './hash';\nimport { fetchf } from './index';\nimport type { FetcherConfig, FetchResponse } from './types/request-handler';\nimport type { CacheEntry } from './types/cache-manager';\nimport { GET, OBJECT, UNDEFINED } from './constants';\nimport { shallowSerialize, sortObject } from './utils';\n\nconst cache = new Map<string, CacheEntry<any>>();\nconst DELIMITER = '|';\nconst MIN_LENGTH_TO_HASH = 64;\n\n/**\n * Generates a unique cache key for a given URL and fetch options, ensuring that key factors\n * like method, headers, body, and other options are included in the cache key.\n * Headers and other objects are sorted by key to ensure consistent cache keys.\n *\n * @param options - The fetch options that may affect the request. The most important are:\n *   @property {string} [method=\"GET\"] - The HTTP method (GET, POST, etc.).\n *   @property {HeadersInit} [headers={}] - The request headers.\n *   @property {BodyInit | null} [body=\"\"] - The body of the request (only for methods like POST, PUT).\n *   @property {RequestMode} [mode=\"cors\"] - The mode for the request (e.g., cors, no-cors, include).\n *   @property {RequestCredentials} [credentials=\"include\"] - Whether to include credentials like cookies.\n *   @property {RequestCache} [cache=\"default\"] - The cache mode (e.g., default, no-store, reload).\n *   @property {RequestRedirect} [redirect=\"follow\"] - How to handle redirects (e.g., follow, error, manual).\n *   @property {string} [referrer=\"\"] - The referrer URL to send with the request.\n *   @property {string} [integrity=\"\"] - Subresource integrity value (a cryptographic hash for resource validation).\n * @returns {string} - A unique cache key based on the URL and request options. Empty if cache is to be burst.\n *\n * @example\n * const cacheKey = generateCacheKey({\n *   url: 'https://api.example.com/data',\n *   method: 'POST',\n *   headers: { 'Content-Type': 'application/json' },\n *   body: JSON.stringify({ name: 'Alice' }),\n *   mode: 'cors',\n *   credentials: 'include',\n * });\n * console.log(cacheKey);\n */\nexport function generateCacheKey(options: FetcherConfig): string {\n  const {\n    url = '',\n    method = GET,\n    headers = null,\n    body = undefined,\n    mode = 'cors',\n    credentials = 'same-origin',\n    cache = 'default',\n    redirect = 'follow',\n    referrer = 'about:client',\n    integrity = '',\n  } = options;\n\n  // Bail early if cache should be burst\n  if (cache === 'reload') {\n    return '';\n  }\n\n  // Sort headers and body + convert sorted to strings for hashing purposes\n  // Native serializer is on avg. 3.5x faster than a Fast Hash or FNV-1a\n  let headersString = '';\n  if (headers) {\n    const obj =\n      headers instanceof Headers\n        ? Object.fromEntries((headers as any).entries())\n        : headers;\n    headersString = shallowSerialize(sortObject(obj));\n    if (headersString.length > MIN_LENGTH_TO_HASH) {\n      headersString = hash(headersString);\n    }\n  }\n\n  let bodyString = '';\n  if (body) {\n    if (typeof body === 'string') {\n      bodyString = body.length < MIN_LENGTH_TO_HASH ? body : hash(body); // hash only if large\n    } else if (body instanceof FormData) {\n      body.forEach((value, key) => {\n        // Append key=value and '&' directly to the result\n        bodyString += key + '=' + value + '&';\n      });\n\n      if (bodyString.length > MIN_LENGTH_TO_HASH) {\n        bodyString = hash(bodyString);\n      }\n    } else if (\n      (typeof Blob !== UNDEFINED && body instanceof Blob) ||\n      (typeof File !== UNDEFINED && body instanceof File)\n    ) {\n      bodyString = 'BF' + body.size + body.type;\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      bodyString = 'AB' + body.byteLength;\n    } else {\n      const o =\n        typeof body === OBJECT\n          ? JSON.stringify(sortObject(body))\n          : String(body);\n\n      bodyString = o.length > MIN_LENGTH_TO_HASH ? hash(o) : o;\n    }\n  }\n\n  // Concatenate all key parts into a cache key string\n  // Template literals are apparently slower\n  return (\n    method +\n    DELIMITER +\n    url +\n    DELIMITER +\n    mode +\n    credentials +\n    cache +\n    redirect +\n    referrer +\n    integrity +\n    DELIMITER +\n    headersString +\n    DELIMITER +\n    bodyString\n  ).replace(/[^\\w\\-_|]/g, ''); // Prevent cache poisoning by removal of anything that isn't letters, numbers, -, _, or |\n}\n\n/**\n * Checks if the cache entry is expired based on its timestamp and the maximum stale time.\n *\n * @param {number} timestamp - The timestamp of the cache entry.\n * @param {number} maxStaleTime - The maximum stale time in seconds.\n * @returns {boolean} - Returns true if the cache entry is expired, false otherwise.\n */\nfunction isCacheExpired(timestamp: number, maxStaleTime: number): boolean {\n  if (!maxStaleTime) {\n    return false;\n  }\n\n  return Date.now() - timestamp > maxStaleTime * 1000;\n}\n\n/**\n * Retrieves a cache entry if it exists and is not expired.\n *\n * @param {string} key Cache key to utilize\n * @param {number} cacheTime - Maximum time to cache entry in seconds.\n * @returns {CacheEntry<T> | null} - The cache entry if it exists and is not expired, null otherwise.\n */\nexport function getCache<T>(\n  key: string,\n  cacheTime: number,\n): CacheEntry<T> | null {\n  const entry = cache.get(key);\n\n  if (entry) {\n    if (!isCacheExpired(entry.timestamp, cacheTime)) {\n      return entry;\n    }\n\n    deleteCache(key);\n  }\n\n  return null;\n}\n\n/**\n * Sets a new cache entry or updates an existing one.\n *\n * @param {string} key Cache key to utilize\n * @param {T} data - The data to be cached.\n * @param {boolean} isLoading - Indicates if the data is currently being fetched.\n */\nexport function setCache<T = unknown>(\n  key: string,\n  data: T,\n  isLoading: boolean = false,\n): void {\n  cache.set(key, {\n    data,\n    isLoading,\n    timestamp: Date.now(),\n  });\n}\n\n/**\n * Revalidates a cache entry by fetching fresh data and updating the cache.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @returns {Promise<void>} - A promise that resolves when the revalidation is complete.\n */\nexport async function revalidate(\n  key: string,\n  config: FetcherConfig,\n): Promise<void> {\n  try {\n    // Fetch fresh data\n    const newData = await fetchf(config.url, {\n      ...config,\n      cache: 'reload',\n    });\n\n    setCache(key, newData);\n  } catch (error) {\n    console.error(`Error revalidating ${config.url}:`, error);\n\n    // Rethrow the error to forward it\n    throw error;\n  }\n}\n\n/**\n * Invalidates (deletes) a cache entry.\n *\n * @param {string} key Cache key to utilize\n */\nexport function deleteCache(key: string): void {\n  cache.delete(key);\n}\n\n/**\n * Prunes the cache by removing entries that have expired based on the provided cache time.\n * @param cacheTime - The maximum time to cache entry.\n */\nexport function pruneCache(cacheTime: number) {\n  cache.forEach((entry, key) => {\n    if (isCacheExpired(entry.timestamp, cacheTime)) {\n      cache.delete(key);\n    }\n  });\n}\n\n/**\n * Mutates a cache entry with new data and optionally revalidates it.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @param {T} newData - The new data to be cached.\n * @param {boolean} revalidateAfter - If true, triggers revalidation after mutation.\n */\nexport function mutate<T>(\n  key: string,\n  config: FetcherConfig,\n  newData: T,\n  revalidateAfter: boolean = false,\n): void {\n  setCache(key, newData);\n\n  if (revalidateAfter) {\n    revalidate(key, config);\n  }\n}\n\n/**\n * Retrieves a cached response if available and valid, otherwise returns null.\n *\n * @template ResponseData - The type of the response data.\n * @template RequestBody - The type of the request body.\n * @template QueryParams - The type of the query parameters.\n * @template PathParams - The type of the path parameters.\n * @param {string | null} cacheKey - The cache key to look up.\n * @param {number | undefined} cacheTime - The maximum time to cache entry.\n * @param {(cfg: any) => boolean | undefined} cacheBuster - Optional function to determine if cache should be bypassed.\n * @param {FetcherConfig<ResponseData, QueryParams, PathParams, RequestBody>} fetcherConfig - The fetcher configuration.\n * @returns {FetchResponse<ResponseData, RequestBody, QueryParams, PathParams> | null} - The cached response or null.\n */\nexport function getCachedResponse<\n  ResponseData,\n  RequestBody,\n  QueryParams,\n  PathParams,\n>(\n  cacheKey: string | null,\n  cacheTime: number | undefined,\n  cacheBuster: ((cfg: any) => boolean) | undefined,\n  fetcherConfig: FetcherConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  >,\n): FetchResponse<ResponseData, RequestBody, QueryParams, PathParams> | null {\n  // If cache key or time is not provided, return null\n  if (!cacheTime || !cacheKey) {\n    return null;\n  }\n\n  // Check if cache should be bypassed\n  if (cacheBuster?.(fetcherConfig)) {\n    return null;\n  }\n\n  // Retrieve the cached entry\n  const cachedEntry = getCache<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  >(cacheKey, cacheTime);\n\n  // If no cached entry or it is expired, return null\n  return cachedEntry ? cachedEntry.data : null;\n}\n","import {\n  GET,\n  APPLICATION_JSON,\n  HEAD,\n  STRING,\n  CHARSET_UTF_8,\n  CONTENT_TYPE,\n  OBJECT,\n} from './constants';\nimport type {\n  FetcherConfig,\n  HeadersObject,\n  Method,\n  RequestConfig,\n  RequestHandlerConfig,\n} from './types/request-handler';\nimport {\n  replaceUrlPathParams,\n  appendQueryParams,\n  isSearchParams,\n  isJSONSerializable,\n} from './utils';\n\nexport const defaultConfig: RequestHandlerConfig = {\n  method: GET,\n  strategy: 'reject',\n  timeout: 30000,\n  dedupeTime: 0,\n  defaultResponse: null,\n  headers: {\n    Accept: APPLICATION_JSON + ', text/plain, */*',\n    'Accept-Encoding': 'gzip, deflate, br',\n  },\n  retry: {\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n  },\n};\n\n/**\n * Build request configuration\n *\n * @param {string} url - Request url\n * @param {RequestConfig} requestConfig - Request config passed when making the request\n * @returns {FetcherConfig} - Provider's instance\n */\nexport const buildConfig = (\n  url: string,\n  requestConfig: RequestConfig,\n): FetcherConfig => {\n  const method = (requestConfig.method ?? GET).toUpperCase() as Method;\n  const isGetAlikeMethod = method === GET || method === HEAD;\n  const dynamicUrl = replaceUrlPathParams(url, requestConfig.urlPathParams);\n\n  let body: RequestConfig['data'] | undefined;\n\n  // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n  if (!isGetAlikeMethod) {\n    body = requestConfig.body ?? requestConfig.data;\n  }\n\n  setContentTypeIfNeeded(method, requestConfig.headers, body);\n\n  // Native fetch compatible settings\n  const credentials = requestConfig.withCredentials\n    ? 'include'\n    : requestConfig.credentials;\n\n  // The explicitly passed query params\n  const explicitParams = requestConfig.params;\n\n  const urlPath = explicitParams\n    ? appendQueryParams(dynamicUrl, explicitParams)\n    : dynamicUrl;\n  const isFullUrl = urlPath.includes('://');\n  const baseURL = isFullUrl\n    ? ''\n    : (requestConfig.baseURL ?? requestConfig.apiUrl);\n\n  // Automatically stringify request body, if possible and when not dealing with strings\n  if (\n    body &&\n    typeof body !== STRING &&\n    !isSearchParams(body) &&\n    isJSONSerializable(body)\n  ) {\n    body = JSON.stringify(body);\n  }\n\n  return {\n    ...requestConfig,\n    url: baseURL + urlPath,\n    method,\n    credentials,\n    body,\n  };\n};\n\n/**\n * Ensures the `Content-Type` header is set to `application/json; charset=utf-8`\n * if it is not already present and the request method and body meet specific conditions.\n *\n * @param headers - The headers object to modify. Can be an instance of `Headers`\n *                  or a plain object conforming to `HeadersInit`.\n * @param method - The HTTP method of the request (e.g., 'PUT', 'DELETE', etc.).\n * @param body - The optional body of the request. If no body is provided and the\n *               method is 'PUT' or 'DELETE', the function exits without modifying headers.\n */\nconst setContentTypeIfNeeded = (\n  method: string,\n  headers?: HeadersInit | HeadersObject,\n  body?: unknown,\n): void => {\n  if (!headers || (!body && ['PUT', 'DELETE'].includes(method))) {\n    return;\n  }\n\n  const contentTypeValue = APPLICATION_JSON + ';' + CHARSET_UTF_8;\n\n  if (headers instanceof Headers) {\n    if (!headers.has(CONTENT_TYPE)) {\n      headers.set(CONTENT_TYPE, contentTypeValue);\n    }\n  } else if (\n    typeof headers === OBJECT &&\n    !Array.isArray(headers) &&\n    !headers[CONTENT_TYPE]\n  ) {\n    headers[CONTENT_TYPE] = contentTypeValue;\n  }\n};\n\n/**\n * Merges the specified property from the base configuration and the new configuration into the target configuration.\n *\n * @param {K} property - The property key to merge from the base and new configurations. Must be a key of RequestHandlerConfig.\n * @param {RequestHandlerConfig} targetConfig - The configuration object that will receive the merged properties.\n * @param {RequestHandlerConfig} baseConfig - The base configuration object that provides default values.\n * @param {RequestHandlerConfig} newConfig - The new configuration object that contains user-specific settings to merge.\n */\nexport const mergeConfig = <K extends keyof RequestHandlerConfig>(\n  property: K,\n  targetConfig: RequestHandlerConfig,\n  baseConfig: RequestHandlerConfig,\n  newConfig: RequestHandlerConfig,\n) => {\n  if (newConfig[property]) {\n    targetConfig[property] = {\n      ...baseConfig[property],\n      ...newConfig[property],\n    };\n  }\n};\n","import type { FetchResponse } from './types';\n\n/**\n * Calculates the number of milliseconds to wait before retrying a request,\n * based on the `Retry-After` HTTP header in the provided response.\n *\n * The function supports both numeric (seconds) and HTTP-date formats for the `Retry-After` header.\n * - If the header is a number, it is interpreted as seconds and converted to milliseconds.\n * - If the header is a date, the function calculates the difference between the date and the current time.\n *\n * @param extendedResponse - The response object containing headers, or `null`.\n * @returns The number of milliseconds to wait before retrying, or `null` if the header is not present or invalid.\n */\nexport function getRetryAfterMs(\n  extendedResponse: FetchResponse | null,\n): number | null {\n  const retryAfter = extendedResponse?.headers?.['retry-after'];\n\n  if (!retryAfter) {\n    return null;\n  }\n\n  // Try parsing as seconds\n  const seconds = Number(retryAfter);\n\n  if (!isNaN(seconds) && seconds >= 0) {\n    return seconds * 1000;\n  }\n\n  // Try parsing as HTTP-date\n  const date = new Date(retryAfter);\n\n  if (!isNaN(date.getTime())) {\n    const ms = date.getTime() - Date.now();\n\n    return ms > 0 ? ms : 0;\n  }\n\n  return null;\n}\n","import type { ExtendedRequestConfig, FetchResponse } from './types';\nimport { delayInvocation } from './utils';\n\n/**\n * Executes a request function with polling, stopping when shouldStopPolling returns true,\n * pollingInterval is not set, or maxAttempts is reached.\n *\n * @template Output The type of the output returned by the request function.\n * @param doRequestOnce - The function that performs a single request (with retries).\n * @param pollingInterval - Interval in ms between polling attempts.\n * @param shouldStopPolling - Function to determine if polling should stop.\n * @param maxAttempts - Maximum number of polling attempts, default: 0 (unlimited).\n * @param pollingDelay - Delay in ms before each polling attempt, default: 0.\n * @returns The final output from the last request.\n */\nexport async function withPolling<\n  Output extends FetchResponse<\n    unknown,\n    unknown,\n    unknown,\n    unknown\n  > = FetchResponse<unknown, unknown, unknown, unknown>,\n>(\n  doRequestOnce: () => Promise<Output>,\n  pollingInterval?: ExtendedRequestConfig['pollingInterval'],\n  shouldStopPolling?: ExtendedRequestConfig['shouldStopPolling'],\n  maxAttempts = 0,\n  pollingDelay = 0,\n): Promise<Output> {\n  let pollingAttempt = 0;\n  let output: Output;\n\n  while (maxAttempts === 0 || pollingAttempt < maxAttempts) {\n    if (pollingDelay > 0) {\n      await delayInvocation(pollingDelay);\n    }\n\n    output = await doRequestOnce();\n\n    pollingAttempt++;\n\n    if (\n      (maxAttempts > 0 && pollingAttempt >= maxAttempts) ||\n      !pollingInterval ||\n      (shouldStopPolling && shouldStopPolling(output, pollingAttempt))\n    ) {\n      break;\n    }\n\n    await delayInvocation(pollingInterval);\n  }\n\n  return output!;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  DefaultResponse,\n  RequestHandlerConfig,\n  RequestConfig,\n  RetryOptions,\n  FetchResponse,\n  RequestHandlerReturnType,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultUrlParams,\n} from './types/api-handler';\nimport { applyInterceptor } from './interceptor-manager';\nimport { ResponseError } from './errors/response-error';\nimport { delayInvocation, sanitizeObject } from './utils';\nimport {\n  queueRequest,\n  removeRequestFromQueue,\n  setInFlightPromise,\n  getInFlightPromise,\n} from './queue-manager';\nimport { ABORT_ERROR, CANCELLED_ERROR } from './constants';\nimport { prepareResponse, parseResponseData } from './response-parser';\nimport { generateCacheKey, getCachedResponse, setCache } from './cache-manager';\nimport { buildConfig, defaultConfig, mergeConfig } from './config-handler';\nimport { getRetryAfterMs } from './retry-handler';\nimport { withPolling } from './polling-handler';\n\n/**\n * Create Request Handler\n *\n * @param {RequestHandlerConfig} config - Configuration object for the request handler\n * @returns {Object} An object with methods for handling requests\n */\nexport function createRequestHandler(\n  config: RequestHandlerConfig | null,\n): RequestHandlerReturnType {\n  const sanitizedConfig = config ? sanitizeObject(config) : {};\n  const handlerConfig: RequestHandlerConfig = {\n    ...defaultConfig,\n    ...sanitizedConfig,\n  };\n\n  mergeConfig('retry', handlerConfig, defaultConfig, sanitizedConfig);\n  mergeConfig('headers', handlerConfig, defaultConfig, sanitizedConfig);\n\n  /**\n   * Immediately create instance of custom fetcher if it is defined\n   */\n  const requestInstance = sanitizedConfig.fetcher?.create?.(handlerConfig);\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Provider's instance\n   */\n  const getInstance = (): CreatedCustomFetcherInstance | null => {\n    return requestInstance || null;\n  };\n\n  /**\n   * Request function to make HTTP requests with the provided URL and configuration.\n   *\n   * @param {string} url - Request URL\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @throws {ResponseError} If the request fails or is cancelled\n   * @returns {Promise<FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>>} Response Data\n   */\n  const request = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    url: string,\n    reqConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    > | null = null,\n  ): Promise<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  > => {\n    const _reqConfig = reqConfig ? sanitizeObject(reqConfig) : {};\n\n    // Ensure immutability\n    const mergedConfig = {\n      ...handlerConfig,\n      ..._reqConfig,\n    };\n\n    mergeConfig('retry', mergedConfig, handlerConfig, _reqConfig);\n    mergeConfig('headers', mergedConfig, handlerConfig, _reqConfig);\n\n    let response: FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    > | null = null;\n    const fetcherConfig = buildConfig(url, mergedConfig);\n\n    const {\n      timeout,\n      cancellable,\n      dedupeTime,\n      cacheTime,\n      cacheKey,\n      pollingInterval = 0,\n    } = mergedConfig;\n\n    // Prevent performance overhead of cache access\n    let _cacheKey: string | null = null;\n\n    // Generate cache key if required\n    if (cacheTime || dedupeTime || cancellable || timeout) {\n      _cacheKey = cacheKey\n        ? cacheKey(fetcherConfig)\n        : generateCacheKey(fetcherConfig);\n    }\n\n    // Cache handling logic\n    if (cacheTime) {\n      const cached = getCachedResponse<\n        ResponseData,\n        RequestBody,\n        QueryParams,\n        PathParams\n      >(_cacheKey, cacheTime, mergedConfig.cacheBuster, fetcherConfig);\n\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Deduplication logic\n    if (_cacheKey && dedupeTime) {\n      const inflight = getInFlightPromise(_cacheKey, dedupeTime);\n\n      if (inflight) {\n        return (await inflight) as FetchResponse<\n          ResponseData,\n          RequestBody,\n          QueryParams,\n          PathParams\n        >;\n      }\n    }\n\n    // The actual request logic as a function (one poll attempt, with retries)\n    const doRequestOnce = async () => {\n      const {\n        retries = 0,\n        delay,\n        backoff,\n        retryOn,\n        shouldRetry,\n        maxDelay,\n        resetTimeout,\n      } = mergedConfig.retry as RetryOptions<\n        ResponseData,\n        QueryParams,\n        PathParams,\n        RequestBody\n      >;\n      let attempt = 0;\n      let waitTime: number = delay || 0;\n      const _retries = retries > 0 ? retries : 0;\n\n      while (attempt <= _retries) {\n        try {\n          // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n          const controller = await queueRequest(\n            _cacheKey,\n            fetcherConfig.url as string,\n            timeout,\n            dedupeTime,\n            cancellable,\n            // Reset timeouts by default or when retries are ON\n            !!(timeout && (!_retries || resetTimeout)),\n          );\n\n          // Shallow copy to ensure basic idempotency\n          // Note that the refrence of the main object does not change here so it is safe in context of queue management and interceptors\n          const requestConfig: RequestConfig = {\n            signal: controller.signal,\n            ...fetcherConfig,\n          };\n\n          // Local interceptors\n          await applyInterceptor(requestConfig, _reqConfig.onRequest);\n\n          // Global interceptors\n          await applyInterceptor(requestConfig, handlerConfig.onRequest);\n\n          response = requestInstance?.request\n            ? await requestInstance.request(requestConfig)\n            : ((await fetch(\n                requestConfig.url as string,\n                requestConfig as RequestInit,\n              )) as unknown as FetchResponse<\n                ResponseData,\n                RequestBody,\n                QueryParams,\n                PathParams\n              >);\n\n          // Add more information to response object\n          if (response instanceof Response) {\n            response.config = requestConfig;\n            response.data = await parseResponseData(response);\n\n            // Check if the response status is not outside the range 200-299 and if so, output error\n            if (!response.ok) {\n              throw new ResponseError(\n                `${requestConfig.method} to ${requestConfig.url} failed! Status: ${response.status || null}`,\n                requestConfig,\n                response,\n              );\n            }\n          }\n\n          // Local interceptors\n          await applyInterceptor(response, _reqConfig.onResponse);\n\n          // Global interceptors\n          await applyInterceptor(response, handlerConfig.onResponse);\n\n          removeRequestFromQueue(_cacheKey);\n\n          const output = prepareResponse<\n            ResponseData,\n            QueryParams,\n            PathParams,\n            RequestBody\n          >(response, requestConfig);\n\n          // Retry on response logic\n          if (\n            shouldRetry &&\n            attempt < _retries &&\n            (await shouldRetry(output, attempt))\n          ) {\n            logger(\n              mergedConfig,\n              `Attempt ${attempt + 1} failed response data check. Retry in ${waitTime}ms.`,\n            );\n\n            await delayInvocation(waitTime);\n\n            waitTime *= backoff || 1;\n            waitTime = Math.min(waitTime, maxDelay || waitTime);\n            attempt++;\n\n            continue; // Retry the request\n          }\n\n          if (\n            cacheTime &&\n            _cacheKey &&\n            (!requestConfig.skipCache ||\n              !requestConfig.skipCache(output, requestConfig))\n          ) {\n            setCache(_cacheKey, output);\n          }\n\n          return output;\n        } catch (err) {\n          const error = err as ResponseError<\n            ResponseData,\n            QueryParams,\n            PathParams,\n            RequestBody\n          >;\n\n          // Append additional information to Network, CORS or any other fetch() errors\n          error.status = error?.status || response?.status || 0;\n          error.statusText = error?.statusText || response?.statusText || '';\n          error.config = fetcherConfig;\n          error.request = fetcherConfig;\n          error.response = response;\n\n          // Prepare Extended Response\n          const output = prepareResponse<\n            ResponseData,\n            QueryParams,\n            PathParams,\n            RequestBody\n          >(response, fetcherConfig, error);\n\n          if (\n            // We check retries provided regardless of the shouldRetry being provided so to avoid infinite loops.\n            // It is a fail-safe so to prevent excessive retry attempts even if custom retry logic suggests a retry.\n            attempt === _retries || // Stop if the maximum retries have been reached\n            !retryOn?.includes(error.status) || // Check if the error status is retryable\n            !shouldRetry ||\n            !(await shouldRetry(output, attempt)) // If shouldRetry is defined, evaluate it\n          ) {\n            if (!isRequestCancelled(error as ResponseError)) {\n              logger(mergedConfig, 'FETCH ERROR', error as ResponseError);\n            }\n\n            // Local interceptors\n            await applyInterceptor(error, _reqConfig.onError);\n\n            // Global interceptors\n            await applyInterceptor(error, handlerConfig.onError);\n\n            // Remove the request from the queue\n            removeRequestFromQueue(_cacheKey);\n\n            // Timeouts and request cancellations using AbortController do not throw any errors unless rejectCancelled is true.\n            // Only handle the error if the request was not cancelled, or if it was cancelled and rejectCancelled is true.\n            const isCancelled = isRequestCancelled(error as ResponseError);\n            const shouldHandleError =\n              !isCancelled || mergedConfig.rejectCancelled;\n\n            if (shouldHandleError) {\n              const errorHandlingStrategy = mergedConfig.strategy;\n\n              // Reject the promise\n              if (errorHandlingStrategy === 'reject') {\n                return Promise.reject(error);\n              } // Hang the promise\n              else if (errorHandlingStrategy === 'silent') {\n                await new Promise(() => null);\n              }\n            }\n\n            return output;\n          }\n\n          // If the error status is 429 (Too Many Requests), handle rate limiting\n          if (error.status === 429) {\n            // Try to extract the \"Retry-After\" value from the response headers\n            const retryAfterMs = getRetryAfterMs(output);\n\n            // If a valid retry-after value is found, override the wait time before next retry\n            if (retryAfterMs !== null) {\n              waitTime = retryAfterMs;\n            }\n          }\n\n          logger(\n            mergedConfig,\n            `Attempt ${attempt + 1} failed. Retry in ${waitTime}ms.`,\n          );\n\n          await delayInvocation(waitTime);\n\n          waitTime *= backoff || 1;\n          waitTime = Math.min(waitTime, maxDelay || waitTime);\n          attempt++;\n        }\n      }\n\n      return prepareResponse<\n        ResponseData,\n        QueryParams,\n        PathParams,\n        RequestBody\n      >(response, fetcherConfig);\n    };\n\n    // If polling is enabled, use withPolling to handle the request\n    const doRequestPromise =\n      pollingInterval > 0\n        ? withPolling<\n            FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n          >(\n            doRequestOnce,\n            pollingInterval,\n            mergedConfig.shouldStopPolling,\n            mergedConfig.maxPollingAttempts,\n            mergedConfig.pollingDelay,\n          )\n        : doRequestOnce();\n\n    // If deduplication is enabled, store the in-flight promise immediately\n    if (_cacheKey && dedupeTime) {\n      setInFlightPromise(_cacheKey, doRequestPromise);\n    }\n\n    return doRequestPromise;\n  };\n\n  return {\n    getInstance,\n    config: handlerConfig,\n    request,\n  };\n}\n\n/**\n * Output error response depending on chosen strategy\n *\n * @param {ResponseError} error               Error instance\n * @returns {boolean}                        True if request is aborted\n */\nconst isRequestCancelled = (error: ResponseError): boolean => {\n  return error.name === ABORT_ERROR || error.name === CANCELLED_ERROR;\n};\n\n/**\n * Logs messages or errors using the configured logger's `warn` method.\n *\n * @param {RequestConfig} reqConfig - Request config passed when making the request\n * @param {...(string | ResponseError<any>)} args - Messages or errors to log.\n */\nconst logger = (\n  reqConfig: RequestConfig,\n  ...args: (string | ResponseError<any>)[]\n): void => {\n  const logger = reqConfig.logger;\n\n  if (logger && logger.warn) {\n    logger.warn(...args);\n  }\n};\n","import type {\n  RequestConfig,\n  FetchResponse,\n  DefaultResponse,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerDefaultMethods,\n  ApiHandlerMethods,\n  DefaultPayload,\n  FallbackValue,\n  FinalParams,\n  FinalResponse,\n  QueryParams,\n  RequestConfigUrlRequired,\n  UrlPathParams,\n} from './types/api-handler';\nimport { createRequestHandler } from './request-handler';\nimport { fetchf } from '.';\nimport { mergeConfig } from './config-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n * @url https://github.com/MattCCC/fetchff\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the ongoing previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {number} config.dedupeTime - Time window, in milliseconds, during which identical requests are deduplicated (treated as single request).\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\". It works only if the response structure includes a single data property.\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsSettings = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = createRequestHandler(config);\n\n  /**\n   * Get Custom Fetcher Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Request Handler's Custom Fetcher Instance\n   */\n  function getInstance(): CreatedCustomFetcherInstance | null {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`Add ${endpointName} to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {keyof EndpointsMethods | string} endpointName - The name of the API endpoint to call.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<FetchResponse<ResponseData>>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<\n    ResponseData = never,\n    QueryParams_ = never,\n    UrlParams = never,\n    RequestBody = never,\n  >(\n    endpointName: keyof EndpointsMethods | string,\n    requestConfig: RequestConfig<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlPathParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    > = {},\n  ): Promise<FetchResponse<FinalResponse<ResponseData, DefaultResponse>>> {\n    // Use global per-endpoint settings\n    const endpointConfig =\n      endpoints[endpointName] ||\n      ({ url: String(endpointName) } as RequestConfigUrlRequired);\n    const url = endpointConfig.url;\n\n    // Block Protocol-relative URLs as they could lead to SSRF (Server-Side Request Forgery)\n    if (url.startsWith('//')) {\n      throw new Error('Protocol-relative URLs are not allowed.');\n    }\n\n    // Prevent potential Server-Side Request Forgery attack and leakage of credentials when same instance is used for external requests\n    const isAbsoluteUrl = url.includes('://');\n\n    if (isAbsoluteUrl) {\n      // Retrigger fetch to ensure completely new instance of handler being triggered for external URLs\n      return await fetchf(url, requestConfig);\n    }\n\n    const mergedConfig = {\n      ...endpointConfig,\n      ...requestConfig,\n    };\n\n    mergeConfig('retry', mergedConfig, endpointConfig, requestConfig);\n    mergeConfig('headers', mergedConfig, endpointConfig, requestConfig);\n\n    const responseData = await requestHandler.request<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    >(url, mergedConfig);\n\n    return responseData;\n  }\n\n  const apiHandler: ApiHandlerDefaultMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  return new Proxy<ApiHandlerMethods<EndpointsMethods, EndpointsSettings>>(\n    apiHandler as ApiHandlerMethods<EndpointsMethods, EndpointsSettings>,\n    {\n      get(_target, prop: string) {\n        if (prop in apiHandler) {\n          return apiHandler[prop as unknown as keyof typeof apiHandler];\n        }\n\n        // Prevent handler from triggering non-existent endpoints\n        if (endpoints[prop]) {\n          return apiHandler.request.bind(null, prop);\n        }\n\n        return handleNonImplemented.bind(null, prop);\n      },\n    },\n  );\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["index_exports","__export","createApiFetcher","fetchf","__toCommonJS","applyInterceptor","object","interceptors","value","interceptor","FetchError","message","request","response","ResponseError","FetchError","message","request","response","APPLICATION_CONTENT_TYPE","APPLICATION_JSON","CHARSET_UTF_8","CONTENT_TYPE","UNDEFINED","OBJECT","STRING","FUNCTION","ABORT_ERROR","TIMEOUT_ERROR","CANCELLED_ERROR","GET","HEAD","MAX_DEPTH","dangerousProps","isSearchParams","data","isObject","value","OBJECT","shallowSerialize","obj","result","key","sanitizeObject","safeObj","prop","sortObject","sortedObj","keys","i","len","appendQueryStringToUrl","baseUrl","queryString","appendQueryParams","url","params","encodedQueryString","s","encode","add","k","v","FUNCTION","buildParams","prefix","depth","replaceUrlPathParams","urlPathParams","match","isJSONSerializable","UNDEFINED","STRING","delayInvocation","ms","resolve","flattenData","processHeaders","headers","headersObject","queue","queueRequest","key","url","timeout","dedupeTime","isCancellable","isTimeoutEnabled","now","item","prevIsCancellable","previousController","timeoutId","ABORT_ERROR","controller","error","TIMEOUT_ERROR","removeRequestFromQueue","setInFlightPromise","key","promise","item","queue","getInFlightPromise","dedupeTime","parseResponseData","response","contentType","CONTENT_TYPE","mimeType","data","APPLICATION_JSON","APPLICATION_CONTENT_TYPE","prepareResponse","requestConfig","error","defaultResponse","OBJECT","flattenData","processHeaders","hash","str","i","len","char","cache","DELIMITER","MIN_LENGTH_TO_HASH","generateCacheKey","options","url","method","GET","headers","body","mode","credentials","redirect","referrer","integrity","headersString","obj","shallowSerialize","sortObject","hash","bodyString","value","key","UNDEFINED","o","OBJECT","isCacheExpired","timestamp","maxStaleTime","getCache","cacheTime","entry","deleteCache","setCache","data","isLoading","deleteCache","key","cache","getCachedResponse","cacheKey","cacheTime","cacheBuster","fetcherConfig","cachedEntry","getCache","defaultConfig","GET","APPLICATION_JSON","buildConfig","url","requestConfig","method","isGetAlikeMethod","HEAD","dynamicUrl","replaceUrlPathParams","body","setContentTypeIfNeeded","credentials","explicitParams","urlPath","appendQueryParams","baseURL","STRING","isSearchParams","isJSONSerializable","headers","contentTypeValue","CHARSET_UTF_8","CONTENT_TYPE","OBJECT","mergeConfig","property","targetConfig","baseConfig","newConfig","getRetryAfterMs","extendedResponse","retryAfter","seconds","date","ms","withPolling","doRequestOnce","pollingInterval","shouldStopPolling","maxAttempts","pollingDelay","pollingAttempt","output","delayInvocation","createRequestHandler","config","sanitizedConfig","sanitizeObject","handlerConfig","defaultConfig","mergeConfig","requestInstance","url","reqConfig","_reqConfig","mergedConfig","response","fetcherConfig","buildConfig","timeout","cancellable","dedupeTime","cacheTime","cacheKey","pollingInterval","_cacheKey","generateCacheKey","cached","getCachedResponse","inflight","getInFlightPromise","doRequestOnce","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","waitTime","_retries","requestConfig","queueRequest","applyInterceptor","parseResponseData","ResponseError","removeRequestFromQueue","output","prepareResponse","logger","delayInvocation","setCache","err","error","isRequestCancelled","errorHandlingStrategy","retryAfterMs","getRetryAfterMs","doRequestPromise","withPolling","setInFlightPromise","ABORT_ERROR","CANCELLED_ERROR","args","createApiFetcher","config","endpoints","requestHandler","createRequestHandler","getInstance","handleNonImplemented","endpointName","request","requestConfig","endpointConfig","url","fetchf","mergedConfig","mergeConfig","apiHandler","_target","prop","fetchf","url","config","createRequestHandler"]}