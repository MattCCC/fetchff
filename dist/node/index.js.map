{"version":3,"sources":["../../src/index.ts","../../src/interceptor-manager.ts","../../src/errors/fetch-error.ts","../../src/errors/response-error.ts","../../src/constants.ts","../../src/utils.ts","../../src/queue-manager.ts","../../src/response-parser.ts","../../src/hash.ts","../../src/cache-manager.ts","../../src/config-handler.ts","../../src/request-handler.ts","../../src/api-handler.ts"],"sourcesContent":["import { createRequestHandler } from './request-handler';\nimport type {\n  DefaultResponse,\n  FetchResponse,\n  RequestHandlerConfig,\n} from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = DefaultResponse>(\n  url: string,\n  config: RequestHandlerConfig<ResponseData> = {},\n): Promise<FetchResponse<ResponseData>> {\n  return createRequestHandler(config).request<ResponseData>(url);\n}\n\nexport { createApiFetcher } from './api-handler';\n\nexport * from './types';\n","type InterceptorFunction<T> = (object: T) => Promise<T>;\n\n/**\n * Applies interceptors to the object. Interceptors can be a single function or an array of functions.\n *\n * @template T - Type of the object.\n * @template I - Type of interceptors.\n *\n * @param {T} object - The object to process.\n * @param {InterceptorFunction<T> | InterceptorFunction<T>[]} [interceptors] - Interceptor function(s).\n *\n * @returns {Promise<void>} - Nothing as the function is non-idempotent.\n */\nexport async function applyInterceptor<\n  T extends object,\n  I = InterceptorFunction<T> | InterceptorFunction<T>[],\n>(object: T, interceptors?: I): Promise<void> {\n  if (!interceptors) {\n    return;\n  }\n\n  if (typeof interceptors === 'function') {\n    const value = await interceptors(object);\n\n    if (value) {\n      Object.assign(object, value);\n    }\n  } else if (Array.isArray(interceptors)) {\n    for (const interceptor of interceptors) {\n      const value = await interceptor(object);\n\n      if (value) {\n        Object.assign(object, value);\n      }\n    }\n  }\n}\n","import type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\n/**\n * This is a base error class\n */\nexport class FetchError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends Error {\n  status: number;\n  statusText: string;\n  request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>;\n  config: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>;\n  response: FetchResponse<ResponseData, RequestBody> | null;\n\n  constructor(\n    message: string,\n    request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n  ) {\n    super(message);\n\n    this.name = 'FetchError';\n\n    this.message = message;\n    this.status = response?.status || 0;\n    this.statusText = response?.statusText || '';\n    this.request = request;\n    this.config = request;\n    this.response = response;\n  }\n}\n","import { FetchError } from './fetch-error';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\nexport class ResponseError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends FetchError<ResponseData, QueryParams, PathParams, RequestBody> {\n  constructor(\n    message: string,\n    request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n  ) {\n    super(message, request, response);\n\n    this.name = 'ResponseError';\n  }\n}\n","export const APPLICATION_CONTENT_TYPE = 'application/';\n\nexport const APPLICATION_JSON = APPLICATION_CONTENT_TYPE + 'json';\nexport const CHARSET_UTF_8 = 'charset=utf-8';\nexport const CONTENT_TYPE = 'Content-Type';\n\nexport const UNDEFINED = 'undefined';\nexport const OBJECT = 'object';\nexport const STRING = 'string';\nexport const FUNCTION = 'function';\n\nexport const ABORT_ERROR = 'AbortError';\nexport const TIMEOUT_ERROR = 'TimeoutError';\nexport const CANCELLED_ERROR = 'CanceledError';\n\nexport const GET = 'GET';\nexport const HEAD = 'HEAD';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { FUNCTION, OBJECT, STRING, UNDEFINED } from './constants';\nimport type {\n  DefaultUrlParams,\n  HeadersObject,\n  QueryParams,\n  UrlPathParams,\n} from './types';\n\n// Prevent stack overflow with recursion depth limit\nconst MAX_DEPTH = 10;\n\nconst dangerousProps = ['__proto__', 'constructor', 'prototype'];\n\nexport function isSearchParams(data: unknown): boolean {\n  return data instanceof URLSearchParams;\n}\n\n/**\n * Determines if a value is a non-null object.\n *\n * @param {any} value - The value to check.\n * @returns {boolean} - True if the value is a non-null object.\n */\nexport function isObject(value: any): value is Record<string, any> {\n  return value !== null && typeof value === OBJECT;\n}\n\n/**\n * Shallowly serializes an object by converting its key-value pairs into a string representation.\n * This function does not recursively serialize nested objects.\n *\n * @param obj - The object to serialize.\n * @returns A string representation of the object's top-level properties.\n */\nexport function shallowSerialize(obj: Record<string, any>): string {\n  let result = '';\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result += key + ':' + obj[key];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Removes properties that could lead to prototype pollution from an object.\n *\n * This function creates a shallow copy of the input object with dangerous\n * properties like '__proto__', 'constructor', and 'prototype' removed.\n *\n * @param obj - The object to sanitize\n * @returns A new object without dangerous properties\n */\nexport function sanitizeObject<T extends Record<string, any>>(\n  obj: T,\n): Partial<T> {\n  if (!obj || typeof obj !== OBJECT || Array.isArray(obj)) {\n    return obj;\n  }\n\n  const safeObj = { ...obj };\n\n  dangerousProps.forEach((prop) => {\n    delete safeObj[prop];\n  });\n\n  return safeObj;\n}\n\n/**\n * Sorts the keys of an object and returns a new object with sorted keys.\n *\n * This function is optimized for performance by minimizing the number of object operations\n * and using a single pass to create the sorted object.\n *\n * @param {Object} obj - The object to be sorted by keys.\n * @returns {Object} - A new object with keys sorted in ascending order.\n */\nexport function sortObject(obj: Record<string, any>): object {\n  const sortedObj = {} as Record<string, string>;\n  const keys = Object.keys(obj);\n\n  keys.sort();\n\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n\n    // Skip dangerous property names to prevent prototype pollution\n    if (dangerousProps.includes(key)) {\n      continue;\n    }\n\n    sortedObj[key] = obj[key];\n  }\n\n  return sortedObj;\n}\n\n/**\n * Appends a query string to a URL, ensuring proper handling of existing query parameters.\n *\n * @param baseUrl - The base URL to which the query string will be appended.\n * @param queryString - The encoded query string to append.\n * @returns The URL with the appended query string, or the original URL if no query string is provided.\n */\nfunction appendQueryStringToUrl(baseUrl: string, queryString: string): string {\n  if (!queryString) {\n    return baseUrl;\n  }\n\n  return baseUrl.includes('?')\n    ? `${baseUrl}&${queryString}`\n    : `${baseUrl}?${queryString}`;\n}\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (isSearchParams(params)) {\n    const encodedQueryString = params.toString();\n\n    return appendQueryStringToUrl(url, encodedQueryString);\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s: string[] = [];\n  const encode = encodeURIComponent;\n  const add = (k: string, v: any) => {\n    v = typeof v === FUNCTION ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encode(k) + '=' + encode(v);\n  };\n\n  const buildParams = (prefix: string, obj: any, depth = 0) => {\n    // Stop recursion if maximum depth is reached\n    if (depth >= MAX_DEPTH) {\n      return s;\n    }\n\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix + '[' + (typeof obj[i] === OBJECT && obj[i] ? i : '') + ']',\n            obj[i],\n            depth + 1,\n          );\n        }\n      } else if (isObject(obj)) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key], depth + 1);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key], depth + 1);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  // This is for compatibility with server frameworks that expect the literal notation\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return appendQueryStringToUrl(url, encodedQueryString);\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams || url.indexOf(':') === -1) {\n    return url;\n  }\n\n  // Use a single RegExp and avoid unnecessary casts and function calls\n  // Precompute keys for faster lookup\n  const params = urlPathParams as DefaultUrlParams;\n\n  // Use a replacer function that avoids extra work\n  return url.replace(/:([a-zA-Z0-9_]+)/g, (match, key) => {\n    // Use hasOwnProperty for strict key existence check\n    if (Object.prototype.hasOwnProperty.call(params, key)) {\n      const value = params[key];\n\n      // Only replace if value is not undefined or null\n      if (value !== undefined && value !== null) {\n        return encodeURIComponent(String(value));\n      }\n    }\n\n    return match;\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  const t = typeof value;\n\n  if (t === UNDEFINED || value === null) {\n    return false;\n  }\n\n  if (t === STRING || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (\n    typeof globalThis !== UNDEFINED &&\n    typeof globalThis.Buffer !== UNDEFINED &&\n    globalThis.Buffer.isBuffer(value)\n  ) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  if (isObject(value)) {\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` (plain object)\n    if (proto === Object.prototype) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === FUNCTION) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n\n/**\n * Recursively flattens the data object if it meets specific criteria.\n *\n * The method checks if the provided `data` is an object with exactly one property named `data`.\n * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n *\n * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n */\nexport function flattenData(data: any, depth = 0): any {\n  if (depth >= MAX_DEPTH) {\n    return data;\n  }\n\n  if (\n    data &&\n    isObject(data) &&\n    typeof data.data !== UNDEFINED &&\n    Object.keys(data).length === 1\n  ) {\n    return flattenData(data.data, depth + 1);\n  }\n\n  return data;\n}\n\n/**\n * Processes headers and returns them as a normalized object.\n *\n * Handles both `Headers` instances and plain objects. Normalizes header keys to lowercase\n * as per RFC 2616 section 4.2.\n *\n * @param headers - The headers to process. Can be an instance of `Headers`, a plain object,\n *                   or `null`. If `null`, an empty object is returned.\n * @returns {HeadersObject} - A normalized headers object with lowercase keys.\n */\nexport function processHeaders(\n  headers?: (HeadersObject & HeadersInit) | null | Headers,\n): HeadersObject {\n  if (!headers) {\n    return {};\n  }\n\n  const headersObject: HeadersObject = {};\n\n  // Handle Headers object with entries() method\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n  } else if (isObject(headers)) {\n    // Handle plain object\n    for (const [key, value] of Object.entries(headers)) {\n      // Normalize keys to lowercase as per RFC 2616 4.2\n      // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n      headersObject[key.toLowerCase()] = value;\n    }\n  }\n\n  return headersObject;\n}\n\nexport interface RetryOptions {\n  retries: number; // Number of retry attempts\n  delay: number; // Initial delay between retries (in milliseconds)\n  backoff?: number; // Backoff multiplier for exponential delay\n  shouldRetry?: (error: any) => boolean; // Function to determine if retry is needed\n}\n\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions,\n): Promise<T> {\n  const { retries, delay, backoff = 1, shouldRetry } = options;\n\n  let attempt = 0;\n  let currentDelay = delay;\n\n  while (attempt <= retries) {\n    try {\n      // Attempt the operation\n      return await operation();\n    } catch (error) {\n      attempt++;\n\n      // Check if we should retry\n      if (attempt > retries || (shouldRetry && !shouldRetry(error))) {\n        throw error; // Rethrow the error if retries are exhausted or not retryable\n      }\n\n      // Log the retry attempt\n      console.warn(\n        `Retry attempt ${attempt} failed. Retrying in ${currentDelay}ms...`,\n        error,\n      );\n\n      // Wait for the specified delay before retrying\n      await new Promise((resolve) => setTimeout(resolve, currentDelay));\n\n      // Apply backoff for the next attempt\n      currentDelay *= backoff;\n    }\n  }\n\n  throw new Error('Operation failed after maximum retries.');\n}\n","import { ABORT_ERROR, TIMEOUT_ERROR } from './constants';\nimport type { RequestConfig } from './types';\nimport type { QueueItem, RequestsQueue } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: RequestsQueue = new Map<RequestConfig, QueueItem>();\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {RequestConfig} config - The request configuration object.\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} isTimeoutEnabled - Whether timeout is enabled.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function queueRequest(\n  config: RequestConfig,\n  timeout: number | undefined,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  isTimeoutEnabled: boolean = true,\n): Promise<AbortController> {\n  const now = Date.now();\n  const item = queue.get(config);\n\n  if (item) {\n    const isCancellable = item[3];\n    const previousController = item[0];\n    const timeoutId = item[1];\n\n    // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n    if (!isCancellable && now - item[2] < dedupeTime) {\n      return previousController;\n    }\n\n    // If the request is too old, remove it and proceed to add a new one\n    // Abort previous request, if applicable, and continue as usual\n    if (isCancellable) {\n      previousController.abort(\n        new DOMException('Aborted due to new request', ABORT_ERROR),\n      );\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n\n  const controller = new AbortController();\n\n  const timeoutId = isTimeoutEnabled\n    ? setTimeout(() => {\n        const error = new DOMException(\n          `${config.url} aborted due to timeout`,\n          TIMEOUT_ERROR,\n        );\n\n        removeRequestFromQueue(config, error);\n      }, timeout)\n    : null;\n\n  queue.set(config, [controller, timeoutId, now, isCancellable]);\n\n  return controller;\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param config - The request configuration.\n * @param {boolean} error - Error payload so to force the request to abort.\n */\nexport async function removeRequestFromQueue(\n  config: RequestConfig,\n  error: DOMException | null | string = null,\n): Promise<void> {\n  const item = queue.get(config);\n\n  if (item) {\n    const controller = item[0];\n    const timeoutId = item[1];\n\n    // If the request is not yet aborted, abort it with the provided error\n    if (error && !controller.signal.aborted) {\n      controller.abort(error);\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n}\n\n/**\n * Gets the AbortController for a request configuration.\n *\n * @param config - The request configuration.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  config: RequestConfig,\n): Promise<AbortController | undefined> {\n  const item = queue.get(config);\n\n  return item?.[0];\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  APPLICATION_CONTENT_TYPE,\n  APPLICATION_JSON,\n  CONTENT_TYPE,\n  OBJECT,\n} from './constants';\nimport {\n  DefaultResponse,\n  FetchResponse,\n  RequestConfig,\n  ResponseError,\n  DefaultParams,\n  DefaultUrlParams,\n  DefaultPayload,\n} from './types';\nimport { flattenData, processHeaders } from './utils';\n\n/**\n * Parses the response data based on the Content-Type header.\n *\n * @param response - The Response object to parse.\n * @returns A Promise that resolves to the parsed data.\n */\nexport async function parseResponseData<ResponseData = DefaultResponse>(\n  response: FetchResponse<ResponseData>,\n): Promise<any> {\n  // Bail early for HEAD requests or status codes, or any requests that never have a body\n  if (!response?.body) {\n    return null;\n  }\n\n  // Get the content-type header once\n  let contentType = (response as Response).headers?.get(CONTENT_TYPE);\n\n  if (contentType) {\n    // Lowercase and trim for consistent matching\n    contentType = contentType.toLowerCase().trim();\n  } else {\n    contentType = '';\n  }\n\n  // Split for mime type without charset\n  const mimeType = contentType.split(';', 1)[0];\n\n  let data;\n\n  try {\n    if (mimeType.includes(APPLICATION_JSON) || mimeType.includes('+json')) {\n      data = await response.json(); // Parse JSON response\n    } else if (mimeType.includes('multipart/form-data')) {\n      data = await response.formData(); // Parse as FormData\n    } else if (mimeType.includes(APPLICATION_CONTENT_TYPE + 'octet-stream')) {\n      data = await response.blob(); // Parse as blob\n    } else if (\n      mimeType.includes(APPLICATION_CONTENT_TYPE + 'x-www-form-urlencoded')\n    ) {\n      data = await response.formData(); // Handle URL-encoded forms\n    } else if (mimeType.startsWith('text/')) {\n      data = await response.text(); // Parse as text\n    } else {\n      try {\n        const responseClone = response.clone();\n\n        // Handle edge case of no content type being provided... We assume JSON here.\n        data = await responseClone.json();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_e) {\n        // Handle streams\n        data = await response.text();\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_error) {\n    // Parsing failed, fallback to null\n    data = null;\n  }\n\n  return data;\n}\n\n/**\n * Prepare response object with additional information.\n *\n * @param Response. It may be \"null\" in case of request being aborted.\n * @param {RequestConfig} requestConfig - Request config\n * @param error - whether the response is erroneous\n * @returns {FetchResponse<ResponseData>} Response data\n */\nexport const prepareResponse = <\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n>(\n  response: FetchResponse<\n    ResponseData,\n    RequestBody,\n    QueryParams,\n    PathParams\n  > | null,\n  requestConfig: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  >,\n  error: ResponseError<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > | null = null,\n): FetchResponse<ResponseData, RequestBody, QueryParams, PathParams> => {\n  const defaultResponse = requestConfig.defaultResponse ?? null;\n\n  // This may happen when request is cancelled.\n  if (!response) {\n    return {\n      ok: false,\n      // Enhance the response with extra information\n      error,\n      data: defaultResponse,\n      headers: null,\n      config: requestConfig,\n    } as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }\n\n  let data = response?.data;\n\n  // Set the default response if the provided data is an empty object\n  if (\n    data === undefined ||\n    data === null ||\n    (typeof data === OBJECT && Object.keys(data).length === 0)\n  ) {\n    data = defaultResponse;\n  }\n\n  if (requestConfig.flattenResponse) {\n    response.data = flattenData(data);\n  }\n\n  // If it's a custom fetcher, and it does not return any Response instance, it may have its own internal handler\n  if (!(response instanceof Response)) {\n    return response;\n  }\n\n  // Native fetch Response extended by extra information\n  return {\n    body: response.body,\n    bodyUsed: response.bodyUsed,\n    ok: response.ok,\n    redirected: response.redirected,\n    type: response.type,\n    url: response.url,\n    status: response.status,\n    statusText: response.statusText,\n\n    // Convert methods to use arrow functions to preserve correct return types\n    blob: () => response.blob(),\n    json: () => response.json(),\n    text: () => response.text(),\n    clone: () => response.clone(),\n    arrayBuffer: () => response.arrayBuffer(),\n    formData: () => response.formData(),\n    bytes: () => response.bytes(),\n\n    // Enhance the response with extra information\n    error,\n    data,\n    headers: processHeaders(response.headers),\n    config: requestConfig,\n  };\n};\n","const PRIME_MULTIPLIER = 31;\n\n/**\n * Computes a hash value for a given string using the variant of djb2 hash function.\n * This hash function is non-cryptographic and designed for speed.\n * @author Daniel J. Bernstein (of djb2)\n *\n * @param str Input string to hash\n * @returns {string} Hash\n */\nexport function hash(str: string): string {\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash * PRIME_MULTIPLIER + char) | 0;\n  }\n\n  return String(hash);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hash } from './hash';\nimport { fetchf } from './index';\nimport type { FetcherConfig } from './types/request-handler';\nimport type { CacheEntry } from './types/cache-manager';\nimport { GET, OBJECT, UNDEFINED } from './constants';\nimport { shallowSerialize, sortObject } from './utils';\n\nconst cache = new Map<string, CacheEntry<any>>();\n\n/**\n * Generates a cache key for a given URL and fetch options, ensuring that key factors\n * like method, headers, body, and other options are included in the cache key.\n * Headers and other objects are sorted by key to ensure consistent cache keys.\n *\n * @param options - The fetch options that may affect the request. The most important are:\n *   @property {string} [method=\"GET\"] - The HTTP method (GET, POST, etc.).\n *   @property {HeadersInit} [headers={}] - The request headers.\n *   @property {BodyInit | null} [body=\"\"] - The body of the request (only for methods like POST, PUT).\n *   @property {RequestMode} [mode=\"cors\"] - The mode for the request (e.g., cors, no-cors, include).\n *   @property {RequestCredentials} [credentials=\"include\"] - Whether to include credentials like cookies.\n *   @property {RequestCache} [cache=\"default\"] - The cache mode (e.g., default, no-store, reload).\n *   @property {RequestRedirect} [redirect=\"follow\"] - How to handle redirects (e.g., follow, error, manual).\n *   @property {string} [referrer=\"\"] - The referrer URL to send with the request.\n *   @property {string} [integrity=\"\"] - Subresource integrity value (a cryptographic hash for resource validation).\n * @returns {string} - A unique cache key based on the URL and request options. Empty if cache is to be burst.\n *\n * @example\n * const cacheKey = generateCacheKey({\n *   url: 'https://api.example.com/data',\n *   method: 'POST',\n *   headers: { 'Content-Type': 'application/json' },\n *   body: JSON.stringify({ name: 'Alice' }),\n *   mode: 'cors',\n *   credentials: 'include',\n * });\n * console.log(cacheKey);\n */\nexport function generateCacheKey(options: FetcherConfig): string {\n  const {\n    url = '',\n    method = GET,\n    headers = {},\n    body = '',\n    mode = 'cors',\n    credentials = 'include',\n    cache = 'default',\n    redirect = 'follow',\n    referrer = '',\n    integrity = '',\n  } = options;\n\n  // Bail early if cache should be burst\n  if (cache === 'reload') {\n    return '';\n  }\n\n  // Sort headers and body + convert sorted to strings for hashing purposes\n  // Native serializer is on avg. 3.5x faster than a Fast Hash or FNV-1a\n  const headersString = shallowSerialize(sortObject(headers));\n\n  let bodyString = '';\n\n  // In majority of cases we do not cache body\n  if (body !== null) {\n    if (typeof body === 'string') {\n      bodyString = hash(body);\n    } else if (body instanceof FormData) {\n      body.forEach((value, key) => {\n        // Append key=value and '&' directly to the result\n        bodyString += key + '=' + value + '&';\n      });\n      bodyString = hash(bodyString);\n    } else if (\n      (typeof Blob !== UNDEFINED && body instanceof Blob) ||\n      (typeof File !== UNDEFINED && body instanceof File)\n    ) {\n      bodyString = 'BF' + body.size + body.type;\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      bodyString = 'AB' + body.byteLength;\n    } else {\n      const o = typeof body === OBJECT ? sortObject(body) : String(body);\n      bodyString = hash(JSON.stringify(o));\n    }\n  }\n\n  // Concatenate all key parts into a cache key string\n  // Template literals are apparently slower\n  return (\n    method +\n    url +\n    mode +\n    credentials +\n    cache +\n    redirect +\n    referrer +\n    integrity +\n    headersString +\n    bodyString\n  ).replace(/[^\\w-_]/g, ''); // Prevent cache poisoning by removal of anything that isn't letters, numbers, - or _\n}\n\n/**\n * Checks if the cache entry is expired based on its timestamp and the maximum stale time.\n *\n * @param {number} timestamp - The timestamp of the cache entry.\n * @param {number} maxStaleTime - The maximum stale time in seconds.\n * @returns {boolean} - Returns true if the cache entry is expired, false otherwise.\n */\nfunction isCacheExpired(timestamp: number, maxStaleTime: number): boolean {\n  if (!maxStaleTime) {\n    return false;\n  }\n\n  return Date.now() - timestamp > maxStaleTime * 1000;\n}\n\n/**\n * Retrieves a cache entry if it exists and is not expired.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} cacheTime - Maximum time to cache entry.\n * @returns {CacheEntry<T> | null} - The cache entry if it exists and is not expired, null otherwise.\n */\nexport function getCache<T>(\n  key: string,\n  cacheTime: number,\n): CacheEntry<T> | null {\n  const entry = cache.get(key);\n\n  if (entry) {\n    if (!isCacheExpired(entry.timestamp, cacheTime)) {\n      return entry;\n    }\n\n    cache.delete(key);\n  }\n\n  return null;\n}\n\n/**\n * Sets a new cache entry or updates an existing one.\n *\n * @param {string} key Cache key to utilize\n * @param {T} data - The data to be cached.\n * @param {boolean} isLoading - Indicates if the data is currently being fetched.\n */\nexport function setCache<T = unknown>(\n  key: string,\n  data: T,\n  isLoading: boolean = false,\n): void {\n  cache.set(key, {\n    data,\n    isLoading,\n    timestamp: Date.now(),\n  });\n}\n\n/**\n * Revalidates a cache entry by fetching fresh data and updating the cache.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @returns {Promise<void>} - A promise that resolves when the revalidation is complete.\n */\nexport async function revalidate(\n  key: string,\n  config: FetcherConfig,\n): Promise<void> {\n  try {\n    // Fetch fresh data\n    const newData = await fetchf(config.url, {\n      ...config,\n      cache: 'reload',\n    });\n\n    setCache(key, newData);\n  } catch (error) {\n    console.error(`Error revalidating ${config.url}:`, error);\n\n    // Rethrow the error to forward it\n    throw error;\n  }\n}\n\n/**\n * Invalidates (deletes) a cache entry.\n *\n * @param {string} key Cache key to utilize\n */\nexport function deleteCache(key: string): void {\n  cache.delete(key);\n}\n\n/**\n * Prunes the cache by removing entries that have expired based on the provided cache time.\n * @param cacheTime - The maximum time to cache entry.\n */\nexport function pruneCache(cacheTime: number) {\n  cache.forEach((entry, key) => {\n    if (isCacheExpired(entry.timestamp, cacheTime)) {\n      cache.delete(key);\n    }\n  });\n}\n\n/**\n * Mutates a cache entry with new data and optionally revalidates it.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @param {T} newData - The new data to be cached.\n * @param {boolean} revalidateAfter - If true, triggers revalidation after mutation.\n */\nexport function mutate<T>(\n  key: string,\n  config: FetcherConfig,\n  newData: T,\n  revalidateAfter: boolean = false,\n): void {\n  setCache(key, newData);\n\n  if (revalidateAfter) {\n    revalidate(key, config);\n  }\n}\n","import {\n  GET,\n  APPLICATION_JSON,\n  HEAD,\n  STRING,\n  CHARSET_UTF_8,\n  CONTENT_TYPE,\n  OBJECT,\n} from './constants';\nimport type {\n  FetcherConfig,\n  HeadersObject,\n  Method,\n  RequestConfig,\n  RequestHandlerConfig,\n} from './types/request-handler';\nimport {\n  replaceUrlPathParams,\n  appendQueryParams,\n  isSearchParams,\n  isJSONSerializable,\n} from './utils';\n\nexport const defaultConfig: RequestHandlerConfig = {\n  method: GET,\n  strategy: 'reject',\n  timeout: 30000,\n  dedupeTime: 1000,\n  defaultResponse: null,\n  headers: {\n    Accept: APPLICATION_JSON + ', text/plain, */*',\n    'Accept-Encoding': 'gzip, deflate, br',\n  },\n  retry: {\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n  },\n};\n\n/**\n * Build request configuration\n *\n * @param {string} url - Request url\n * @param {RequestConfig} requestConfig - Request config passed when making the request\n * @returns {FetcherConfig} - Provider's instance\n */\nexport const buildConfig = (\n  url: string,\n  requestConfig: RequestConfig,\n): FetcherConfig => {\n  const method = (requestConfig.method ?? GET).toUpperCase() as Method;\n  const isGetAlikeMethod = method === GET || method === HEAD;\n  const dynamicUrl = replaceUrlPathParams(url, requestConfig.urlPathParams);\n\n  let body: RequestConfig['data'] | undefined;\n\n  // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n  if (!isGetAlikeMethod) {\n    body = requestConfig.body ?? requestConfig.data;\n  }\n\n  const headers = requestConfig.headers as HeadersInit | HeadersObject;\n\n  setContentTypeIfNeeded(method, headers, body);\n\n  // Native fetch compatible settings\n  const credentials = requestConfig.withCredentials\n    ? 'include'\n    : requestConfig.credentials;\n\n  // The explicitly passed query params\n  const explicitParams = requestConfig.params;\n\n  const urlPath = explicitParams\n    ? appendQueryParams(dynamicUrl, explicitParams)\n    : dynamicUrl;\n  const isFullUrl = urlPath.includes('://');\n  const baseURL = isFullUrl\n    ? ''\n    : (requestConfig.baseURL ?? requestConfig.apiUrl);\n\n  // Automatically stringify request body, if possible and when not dealing with strings\n  if (\n    body &&\n    typeof body !== STRING &&\n    !isSearchParams(body) &&\n    isJSONSerializable(body)\n  ) {\n    body = JSON.stringify(body);\n  }\n\n  return {\n    ...requestConfig,\n    url: baseURL + urlPath,\n    method,\n    credentials,\n    body,\n  };\n};\n\n/**\n * Ensures the `Content-Type` header is set to `application/json; charset=utf-8`\n * if it is not already present and the request method and body meet specific conditions.\n *\n * @param headers - The headers object to modify. Can be an instance of `Headers`\n *                  or a plain object conforming to `HeadersInit`.\n * @param method - The HTTP method of the request (e.g., 'PUT', 'DELETE', etc.).\n * @param body - The optional body of the request. If no body is provided and the\n *               method is 'PUT' or 'DELETE', the function exits without modifying headers.\n */\nconst setContentTypeIfNeeded = (\n  method: string,\n  headers: HeadersInit | HeadersObject,\n  body?: unknown,\n): void => {\n  if (!body && ['PUT', 'DELETE'].includes(method)) {\n    return;\n  }\n\n  const contentTypeValue = APPLICATION_JSON + ';' + CHARSET_UTF_8;\n\n  if (headers instanceof Headers) {\n    if (!headers.has(CONTENT_TYPE)) {\n      headers.set(CONTENT_TYPE, contentTypeValue);\n    }\n  } else if (\n    typeof headers === OBJECT &&\n    !Array.isArray(headers) &&\n    !headers[CONTENT_TYPE]\n  ) {\n    headers[CONTENT_TYPE] = contentTypeValue;\n  }\n};\n\n/**\n * Merges the specified property from the base configuration and the new configuration into the target configuration.\n *\n * @param {K} property - The property key to merge from the base and new configurations. Must be a key of RequestHandlerConfig.\n * @param {RequestHandlerConfig} targetConfig - The configuration object that will receive the merged properties.\n * @param {RequestHandlerConfig} baseConfig - The base configuration object that provides default values.\n * @param {RequestHandlerConfig} newConfig - The new configuration object that contains user-specific settings to merge.\n */\nexport const mergeConfig = <K extends keyof RequestHandlerConfig>(\n  property: K,\n  targetConfig: RequestHandlerConfig,\n  baseConfig: RequestHandlerConfig,\n  newConfig: RequestHandlerConfig,\n) => {\n  if (newConfig[property]) {\n    targetConfig[property] = {\n      ...baseConfig[property],\n      ...newConfig[property],\n    };\n  }\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  DefaultResponse,\n  RequestHandlerConfig,\n  RequestConfig,\n  RetryOptions,\n  FetchResponse,\n  RequestHandlerReturnType,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultUrlParams,\n} from './types/api-handler';\nimport { applyInterceptor } from './interceptor-manager';\nimport { ResponseError } from './errors/response-error';\nimport { delayInvocation, sanitizeObject } from './utils';\nimport { queueRequest, removeRequestFromQueue } from './queue-manager';\nimport { ABORT_ERROR, CANCELLED_ERROR } from './constants';\nimport { prepareResponse, parseResponseData } from './response-parser';\nimport { generateCacheKey, getCache, setCache } from './cache-manager';\nimport { buildConfig, defaultConfig, mergeConfig } from './config-handler';\n\n/**\n * Create Request Handler\n *\n * @param {RequestHandlerConfig} config - Configuration object for the request handler\n * @returns {Object} An object with methods for handling requests\n */\nexport function createRequestHandler(\n  config: RequestHandlerConfig | null,\n): RequestHandlerReturnType {\n  const sanitizedConfig = config ? sanitizeObject(config) : {};\n  const handlerConfig: RequestHandlerConfig = {\n    ...defaultConfig,\n    ...sanitizedConfig,\n  };\n\n  mergeConfig('retry', handlerConfig, defaultConfig, sanitizedConfig);\n  mergeConfig('headers', handlerConfig, defaultConfig, sanitizedConfig);\n\n  /**\n   * Immediately create instance of custom fetcher if it is defined\n   */\n  const requestInstance = sanitizedConfig.fetcher?.create?.(handlerConfig);\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Provider's instance\n   */\n  const getInstance = (): CreatedCustomFetcherInstance | null => {\n    return requestInstance || null;\n  };\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @throws {ResponseError}\n   * @returns {Promise<FetchResponse<ResponseData>>} Response Data\n   */\n  const request = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    url: string,\n    reqConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    > | null = null,\n  ): Promise<FetchResponse<ResponseData, RequestBody>> => {\n    const _reqConfig = reqConfig ? sanitizeObject(reqConfig) : {};\n\n    // Ensure immutability\n    const mergedConfig = {\n      ...handlerConfig,\n      ..._reqConfig,\n    };\n\n    mergeConfig('retry', mergedConfig, handlerConfig, _reqConfig);\n    mergeConfig('headers', mergedConfig, handlerConfig, _reqConfig);\n\n    let response: FetchResponse<ResponseData> | null = null;\n    const fetcherConfig = buildConfig(url, mergedConfig);\n\n    const {\n      timeout,\n      cancellable,\n      dedupeTime,\n      pollingInterval,\n      shouldStopPolling,\n      cacheTime,\n      cacheKey,\n    } = mergedConfig;\n\n    // Prevent performance overhead of cache access\n    let _cacheKey: string | null = null;\n\n    if (cacheTime) {\n      _cacheKey = cacheKey\n        ? cacheKey(fetcherConfig)\n        : generateCacheKey(fetcherConfig);\n\n      if (_cacheKey) {\n        const shouldBust = mergedConfig.cacheBuster?.(fetcherConfig);\n\n        if (!shouldBust) {\n          const cachedEntry = getCache<FetchResponse<ResponseData>>(\n            _cacheKey,\n            cacheTime,\n          );\n\n          if (cachedEntry) {\n            // Serve stale data from cache\n            return cachedEntry.data;\n          }\n        }\n      }\n    }\n\n    const {\n      retries = 0,\n      delay,\n      backoff,\n      retryOn,\n      shouldRetry,\n      maxDelay,\n      resetTimeout,\n    } = mergedConfig.retry as Required<\n      RetryOptions<ResponseData, QueryParams, PathParams, RequestBody>\n    >;\n\n    let attempt = 0;\n    let pollingAttempt = 0;\n    let waitTime: number = delay;\n    const _retries = retries > 0 ? retries : 0;\n\n    while (attempt <= _retries) {\n      try {\n        // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n        const controller = await queueRequest(\n          fetcherConfig,\n          timeout,\n          dedupeTime,\n          cancellable,\n          // Reset timeouts by default or when retries are ON\n          !!(timeout && (!_retries || resetTimeout)),\n        );\n\n        // Shallow copy to ensure basic idempotency\n        // Note that the refrence of the main object does not change here so it is safe in context of queue management and interceptors\n        const requestConfig: RequestConfig = {\n          signal: controller.signal,\n          ...fetcherConfig,\n        };\n\n        // Local interceptors\n        await applyInterceptor(requestConfig, _reqConfig.onRequest);\n\n        // Global interceptors\n        await applyInterceptor(requestConfig, handlerConfig.onRequest);\n\n        response = requestInstance?.request\n          ? await requestInstance.request(requestConfig)\n          : ((await fetch(\n              requestConfig.url as string,\n              requestConfig as RequestInit,\n            )) as unknown as FetchResponse<ResponseData, RequestBody>);\n\n        // Add more information to response object\n        if (response instanceof Response) {\n          response.config = requestConfig;\n          response.data = await parseResponseData(response);\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseError(\n              `${requestConfig.method} to ${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        await applyInterceptor(response, _reqConfig.onResponse);\n\n        // Global interceptors\n        await applyInterceptor(response, handlerConfig.onResponse);\n\n        removeRequestFromQueue(fetcherConfig);\n\n        // If polling is not required, or polling attempts are exhausted\n        const output = prepareResponse<\n          ResponseData,\n          QueryParams,\n          PathParams,\n          RequestBody\n        >(response, requestConfig);\n\n        if (\n          shouldRetry &&\n          attempt < retries &&\n          (await shouldRetry(output, attempt))\n        ) {\n          logger(\n            mergedConfig,\n            `Attempt ${attempt + 1} failed response data check. Retry in ${waitTime}ms.`,\n          );\n\n          await delayInvocation(waitTime);\n\n          waitTime *= backoff;\n          waitTime = Math.min(waitTime, maxDelay);\n          attempt++;\n          continue; // Retry the request\n        }\n\n        // Polling logic\n        if (\n          pollingInterval &&\n          (!shouldStopPolling || !shouldStopPolling(output, pollingAttempt))\n        ) {\n          // Restart the main retry loop\n          pollingAttempt++;\n\n          logger(mergedConfig, 'Polling attempt ' + pollingAttempt + '...');\n\n          await delayInvocation(pollingInterval);\n\n          continue;\n        }\n\n        if (\n          cacheTime &&\n          _cacheKey &&\n          requestConfig.skipCache &&\n          !requestConfig.skipCache(output, requestConfig)\n        ) {\n          setCache(_cacheKey, output);\n        }\n\n        return output;\n      } catch (err) {\n        const error = err as ResponseError<\n          ResponseData,\n          QueryParams,\n          PathParams,\n          RequestBody\n        >;\n\n        // Append additional information to Network, CORS or any other fetch() errors\n        error.status = error?.status || response?.status || 0;\n        error.statusText = error?.statusText || response?.statusText || '';\n        error.config = fetcherConfig;\n        error.request = fetcherConfig;\n        error.response = response;\n\n        // Prepare Extended Response\n        const output = prepareResponse<\n          ResponseData,\n          QueryParams,\n          PathParams,\n          RequestBody\n        >(response, fetcherConfig, error);\n\n        if (\n          // We check retries provided regardless of the shouldRetry being provided so to avoid infinite loops.\n          // It is a fail-safe so to prevent excessive retry attempts even if custom retry logic suggests a retry.\n          attempt === retries || // Stop if the maximum retries have been reached\n          !retryOn?.includes(error.status) || // Check if the error status is retryable\n          !shouldRetry ||\n          !(await shouldRetry(output, attempt)) // If shouldRetry is defined, evaluate it\n        ) {\n          if (!isRequestCancelled(error as ResponseError)) {\n            logger(mergedConfig, 'FETCH ERROR', error as ResponseError);\n          }\n\n          // Local interceptors\n          await applyInterceptor(error, _reqConfig.onError);\n\n          // Global interceptors\n          await applyInterceptor(error, handlerConfig.onError);\n\n          // Remove the request from the queue\n          removeRequestFromQueue(fetcherConfig);\n\n          // Only handle the error if the request was not cancelled,\n          // or if it was cancelled and rejectCancelled is true\n          const isCancelled = isRequestCancelled(error as ResponseError);\n          const shouldHandleError =\n            !isCancelled || mergedConfig.rejectCancelled;\n\n          if (shouldHandleError) {\n            const errorHandlingStrategy = mergedConfig.strategy;\n\n            // Reject the promise\n            if (errorHandlingStrategy === 'reject') {\n              return Promise.reject(error);\n            } // Hang the promise\n            else if (errorHandlingStrategy === 'silent') {\n              await new Promise(() => null);\n            }\n          }\n\n          return output;\n        }\n\n        logger(\n          mergedConfig,\n          `Attempt ${attempt + 1} failed. Retry in ${waitTime}ms.`,\n        );\n\n        await delayInvocation(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return prepareResponse<ResponseData, QueryParams, PathParams, RequestBody>(\n      response,\n      fetcherConfig,\n    );\n  };\n\n  return {\n    getInstance,\n    config: handlerConfig,\n    request,\n  };\n}\n\n/**\n * Output error response depending on chosen strategy\n *\n * @param {ResponseError} error               Error instance\n * @returns {boolean}                        True if request is aborted\n */\nconst isRequestCancelled = (error: ResponseError): boolean => {\n  return error.name === ABORT_ERROR || error.name === CANCELLED_ERROR;\n};\n\n/**\n * Logs messages or errors using the configured logger's `warn` method.\n *\n * @param {RequestConfig} reqConfig - Request config passed when making the request\n * @param {...(string | ResponseError<any>)} args - Messages or errors to log.\n */\nconst logger = (\n  reqConfig: RequestConfig,\n  ...args: (string | ResponseError<any>)[]\n): void => {\n  const logger = reqConfig.logger;\n\n  if (logger && logger.warn) {\n    logger.warn(...args);\n  }\n};\n","import type {\n  RequestConfig,\n  FetchResponse,\n  DefaultResponse,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerDefaultMethods,\n  ApiHandlerMethods,\n  DefaultPayload,\n  FallbackValue,\n  FinalParams,\n  FinalResponse,\n  QueryParams,\n  RequestConfigUrlRequired,\n  UrlPathParams,\n} from './types/api-handler';\nimport { createRequestHandler } from './request-handler';\nimport { fetchf } from '.';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n * @url https://github.com/MattCCC/fetchff\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the ongoing previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {number} config.dedupeTime - Time window, in milliseconds, during which identical requests are deduplicated (treated as single request).\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\". It works only if the response structure includes a single data property.\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsSettings = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = createRequestHandler(config);\n\n  /**\n   * Get Custom Fetcher Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Request Handler's Custom Fetcher Instance\n   */\n  function getInstance(): CreatedCustomFetcherInstance | null {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`Add ${endpointName} to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {keyof EndpointsMethods | string} endpointName - The name of the API endpoint to call.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<FetchResponse<ResponseData>>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<\n    ResponseData = never,\n    QueryParams_ = never,\n    UrlParams = never,\n    RequestBody = never,\n  >(\n    endpointName: keyof EndpointsMethods | string,\n    requestConfig: RequestConfig<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlPathParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    > = {},\n  ): Promise<FetchResponse<FinalResponse<ResponseData, DefaultResponse>>> {\n    // Use global per-endpoint settings\n    const endpointConfig =\n      endpoints[endpointName] ||\n      ({ url: String(endpointName) } as RequestConfigUrlRequired);\n    const url = endpointConfig.url;\n\n    // Block Protocol-relative URLs as they could lead to SSRF (Server-Side Request Forgery)\n    if (url.startsWith('//')) {\n      throw new Error('Protocol-relative URLs are not allowed.');\n    }\n\n    // Prevent potential Server-Side Request Forgery attack and leakage of credentials when same instance is used for external requests\n    const isAbsoluteUrl = url.includes('://');\n\n    if (isAbsoluteUrl) {\n      // Retrigger fetch to ensure completely new instance of handler being triggered for external URLs\n      return await fetchf(url, requestConfig);\n    }\n\n    const responseData = await requestHandler.request<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    >(url, {\n      ...endpointConfig,\n      ...requestConfig,\n    });\n\n    return responseData;\n  }\n\n  const apiHandler: ApiHandlerDefaultMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  return new Proxy<ApiHandlerMethods<EndpointsMethods, EndpointsSettings>>(\n    apiHandler as ApiHandlerMethods<EndpointsMethods, EndpointsSettings>,\n    {\n      get(_target, prop: string) {\n        if (prop in apiHandler) {\n          return apiHandler[prop as unknown as keyof typeof apiHandler];\n        }\n\n        // Prevent handler from triggering non-existent endpoints\n        if (endpoints[prop]) {\n          return apiHandler.request.bind(null, prop);\n        }\n\n        return handleNonImplemented.bind(null, prop);\n      },\n    },\n  );\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["index_exports","__export","createApiFetcher","fetchf","__toCommonJS","applyInterceptor","object","interceptors","value","interceptor","FetchError","message","request","response","ResponseError","FetchError","message","request","response","APPLICATION_CONTENT_TYPE","APPLICATION_JSON","CHARSET_UTF_8","CONTENT_TYPE","UNDEFINED","OBJECT","STRING","FUNCTION","ABORT_ERROR","TIMEOUT_ERROR","CANCELLED_ERROR","GET","HEAD","MAX_DEPTH","dangerousProps","isSearchParams","data","isObject","value","OBJECT","shallowSerialize","obj","result","key","sanitizeObject","safeObj","prop","sortObject","sortedObj","keys","i","len","appendQueryStringToUrl","baseUrl","queryString","appendQueryParams","url","params","encodedQueryString","s","encode","add","k","v","FUNCTION","buildParams","prefix","depth","replaceUrlPathParams","urlPathParams","match","isJSONSerializable","UNDEFINED","STRING","delayInvocation","ms","resolve","flattenData","processHeaders","headers","headersObject","queue","queueRequest","config","timeout","dedupeTime","isCancellable","isTimeoutEnabled","now","item","previousController","timeoutId","ABORT_ERROR","controller","error","TIMEOUT_ERROR","removeRequestFromQueue","parseResponseData","response","contentType","CONTENT_TYPE","mimeType","data","APPLICATION_JSON","APPLICATION_CONTENT_TYPE","prepareResponse","requestConfig","error","defaultResponse","OBJECT","flattenData","processHeaders","hash","str","i","len","char","cache","generateCacheKey","options","url","method","GET","headers","body","mode","credentials","redirect","referrer","integrity","headersString","shallowSerialize","sortObject","bodyString","hash","value","key","UNDEFINED","o","OBJECT","isCacheExpired","timestamp","maxStaleTime","getCache","cacheTime","entry","setCache","data","isLoading","defaultConfig","GET","APPLICATION_JSON","buildConfig","url","requestConfig","method","isGetAlikeMethod","HEAD","dynamicUrl","replaceUrlPathParams","body","headers","setContentTypeIfNeeded","credentials","explicitParams","urlPath","appendQueryParams","baseURL","STRING","isSearchParams","isJSONSerializable","contentTypeValue","CHARSET_UTF_8","CONTENT_TYPE","OBJECT","mergeConfig","property","targetConfig","baseConfig","newConfig","createRequestHandler","config","sanitizedConfig","sanitizeObject","handlerConfig","defaultConfig","mergeConfig","requestInstance","url","reqConfig","_reqConfig","mergedConfig","response","fetcherConfig","buildConfig","timeout","cancellable","dedupeTime","pollingInterval","shouldStopPolling","cacheTime","cacheKey","_cacheKey","generateCacheKey","cachedEntry","getCache","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","pollingAttempt","waitTime","_retries","requestConfig","queueRequest","applyInterceptor","parseResponseData","ResponseError","removeRequestFromQueue","output","prepareResponse","logger","delayInvocation","setCache","err","error","isRequestCancelled","errorHandlingStrategy","ABORT_ERROR","CANCELLED_ERROR","args","createApiFetcher","config","endpoints","requestHandler","createRequestHandler","getInstance","handleNonImplemented","endpointName","request","requestConfig","endpointConfig","url","fetchf","apiHandler","_target","prop","fetchf","url","config","createRequestHandler"]}