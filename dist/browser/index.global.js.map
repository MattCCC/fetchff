{"version":3,"sources":["../../src/index.ts","../../src/interceptor-manager.ts","../../src/errors/fetch-error.ts","../../src/errors/response-error.ts","../../src/constants.ts","../../src/utils.ts","../../src/queue-manager.ts","../../src/response-parser.ts","../../src/hash.ts","../../src/cache-manager.ts","../../src/request-handler.ts","../../src/api-handler.ts"],"sourcesContent":["import { createRequestHandler } from './request-handler';\nimport type {\n  DefaultResponse,\n  FetchResponse,\n  RequestHandlerConfig,\n} from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = DefaultResponse>(\n  url: string,\n  config: RequestHandlerConfig<ResponseData> = {},\n): Promise<FetchResponse<ResponseData>> {\n  return createRequestHandler(config).request<ResponseData>(url, config);\n}\n\nexport * from './types';\nexport * from './api-handler';\n","type InterceptorFunction<T> = (object: T) => Promise<T>;\n\n/**\n * Applies interceptors to the object. Interceptors can be a single function or an array of functions.\n *\n * @template T - Type of the object.\n * @template I - Type of interceptors.\n *\n * @param {T} object - The object to process.\n * @param {InterceptorFunction<T> | InterceptorFunction<T>[]} [interceptors] - Interceptor function(s).\n *\n * @returns {Promise<void>} - Nothing as the function is non-idempotent.\n */\nexport async function applyInterceptor<\n  T extends object,\n  I = InterceptorFunction<T> | InterceptorFunction<T>[],\n>(object: T, interceptors?: I): Promise<void> {\n  if (!interceptors) {\n    return;\n  }\n\n  if (typeof interceptors === 'function') {\n    const value = await interceptors(object);\n\n    if (value) {\n      Object.assign(object, value);\n    }\n  } else if (Array.isArray(interceptors)) {\n    for (const interceptor of interceptors) {\n      const value = await interceptor(object);\n\n      if (value) {\n        Object.assign(object, value);\n      }\n    }\n  }\n}\n","import type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\n/**\n * This is a base error class\n */\nexport class FetchError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends Error {\n  status: number;\n  statusText: string;\n  request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>;\n  config: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>;\n  response: FetchResponse<ResponseData, RequestBody> | null;\n\n  constructor(\n    message: string,\n    request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n  ) {\n    super(message);\n\n    this.name = 'FetchError';\n\n    this.message = message;\n    this.status = response?.status || 0;\n    this.statusText = response?.statusText || '';\n    this.request = request;\n    this.config = request;\n    this.response = response;\n  }\n}\n","import { FetchError } from './fetch-error';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '../types';\n\nexport class ResponseError<\n  ResponseData = DefaultResponse,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n  RequestBody = DefaultPayload,\n> extends FetchError<ResponseData, QueryParams, PathParams, RequestBody> {\n  constructor(\n    message: string,\n    request: RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n  ) {\n    super(message, request, response);\n\n    this.name = 'ResponseError';\n  }\n}\n","export const APPLICATION_CONTENT_TYPE = 'application/';\n\nexport const APPLICATION_JSON = APPLICATION_CONTENT_TYPE + 'json';\nexport const CHARSET_UTF_8 = 'charset=utf-8';\nexport const CONTENT_TYPE = 'Content-Type';\n\nexport const UNDEFINED = 'undefined';\nexport const OBJECT = 'object';\nexport const STRING = 'string';\nexport const FUNCTION = 'function';\n\nexport const ABORT_ERROR = 'AbortError';\nexport const TIMEOUT_ERROR = 'TimeoutError';\nexport const CANCELLED_ERROR = 'CanceledError';\n\nexport const GET = 'GET';\nexport const HEAD = 'HEAD';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { FUNCTION, OBJECT, STRING, UNDEFINED } from './constants';\nimport type {\n  DefaultUrlParams,\n  HeadersObject,\n  QueryParams,\n  UrlPathParams,\n} from './types';\n\n// Prevent stack overflow with recursion depth limit\nconst MAX_DEPTH = 10;\n\nconst dangerousProps = ['__proto__', 'constructor', 'prototype'];\n\nexport function isSearchParams(data: unknown): boolean {\n  return data instanceof URLSearchParams;\n}\n\n/**\n * Determines if a value is a non-null object.\n *\n * @param {any} value - The value to check.\n * @returns {boolean} - True if the value is a non-null object.\n */\nexport function isObject(value: any): value is Record<string, any> {\n  return value !== null && typeof value === OBJECT;\n}\n\n/**\n * Shallowly serializes an object by converting its key-value pairs into a string representation.\n * This function does not recursively serialize nested objects.\n *\n * @param obj - The object to serialize.\n * @returns A string representation of the object's top-level properties.\n */\nexport function shallowSerialize(obj: Record<string, any>): string {\n  let result = '';\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result += key + ':' + obj[key];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Removes properties that could lead to prototype pollution from an object.\n *\n * This function creates a shallow copy of the input object with dangerous\n * properties like '__proto__', 'constructor', and 'prototype' removed.\n *\n * @param obj - The object to sanitize\n * @returns A new object without dangerous properties\n */\nexport function sanitizeObject<T extends Record<string, any>>(\n  obj: T,\n): Partial<T> {\n  if (!obj || typeof obj !== OBJECT || Array.isArray(obj)) {\n    return obj;\n  }\n\n  const safeObj = { ...obj };\n\n  dangerousProps.forEach((prop) => {\n    delete safeObj[prop];\n  });\n\n  return safeObj;\n}\n\n/**\n * Sorts the keys of an object and returns a new object with sorted keys.\n *\n * This function is optimized for performance by minimizing the number of object operations\n * and using a single pass to create the sorted object.\n *\n * @param {Object} obj - The object to be sorted by keys.\n * @returns {Object} - A new object with keys sorted in ascending order.\n */\nexport function sortObject(obj: Record<string, any>): object {\n  const sortedObj = {} as Record<string, string>;\n  const keys = Object.keys(obj);\n\n  keys.sort();\n\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n\n    // Skip dangerous property names to prevent prototype pollution\n    if (dangerousProps.includes(key)) {\n      continue;\n    }\n\n    sortedObj[key] = obj[key];\n  }\n\n  return sortedObj;\n}\n\n/**\n * Appends a query string to a URL, ensuring proper handling of existing query parameters.\n *\n * @param baseUrl - The base URL to which the query string will be appended.\n * @param queryString - The encoded query string to append.\n * @returns The URL with the appended query string, or the original URL if no query string is provided.\n */\nfunction appendQueryStringToUrl(baseUrl: string, queryString: string): string {\n  if (!queryString) {\n    return baseUrl;\n  }\n\n  return baseUrl.includes('?')\n    ? `${baseUrl}&${queryString}`\n    : `${baseUrl}?${queryString}`;\n}\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (isSearchParams(params)) {\n    const encodedQueryString = params.toString();\n\n    return appendQueryStringToUrl(url, encodedQueryString);\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s: string[] = [];\n  const encode = encodeURIComponent;\n  const add = (k: string, v: any) => {\n    v = typeof v === FUNCTION ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encode(k) + '=' + encode(v);\n  };\n\n  const buildParams = (prefix: string, obj: any, depth = 0) => {\n    // Stop recursion if maximum depth is reached\n    if (depth >= MAX_DEPTH) {\n      return s;\n    }\n\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix + '[' + (typeof obj[i] === OBJECT && obj[i] ? i : '') + ']',\n            obj[i],\n            depth + 1,\n          );\n        }\n      } else if (isObject(obj)) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key], depth + 1);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key], depth + 1);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  // This is for compatibility with server frameworks that expect the literal notation\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return appendQueryStringToUrl(url, encodedQueryString);\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams) {\n    return url;\n  }\n\n  return url.replace(/:\\w+/g, (str): string => {\n    const word = str.substring(1);\n\n    if ((urlPathParams as DefaultUrlParams)[word]) {\n      return encodeURIComponent(\n        String((urlPathParams as DefaultUrlParams)[word]),\n      );\n    }\n\n    return str;\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  const t = typeof value;\n\n  if (t === UNDEFINED || value === null) {\n    return false;\n  }\n\n  if (t === STRING || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (\n    typeof globalThis !== UNDEFINED &&\n    typeof globalThis.Buffer !== UNDEFINED &&\n    globalThis.Buffer.isBuffer(value)\n  ) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  if (isObject(value)) {\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` (plain object)\n    if (proto === Object.prototype) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === FUNCTION) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n\n/**\n * Recursively flattens the data object if it meets specific criteria.\n *\n * The method checks if the provided `data` is an object with exactly one property named `data`.\n * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n *\n * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n */\nexport function flattenData(data: any, depth = 0): any {\n  if (depth >= MAX_DEPTH) {\n    return data;\n  }\n\n  if (\n    data &&\n    isObject(data) &&\n    typeof data.data !== UNDEFINED &&\n    Object.keys(data).length === 1\n  ) {\n    return flattenData(data.data, depth + 1);\n  }\n\n  return data;\n}\n\n/**\n * Processes headers and returns them as a normalized object.\n *\n * Handles both `Headers` instances and plain objects. Normalizes header keys to lowercase\n * as per RFC 2616 section 4.2.\n *\n * @param headers - The headers to process. Can be an instance of `Headers`, a plain object,\n *                   or `null`. If `null`, an empty object is returned.\n * @returns {HeadersObject} - A normalized headers object with lowercase keys.\n */\nexport function processHeaders(\n  headers?: (HeadersObject & HeadersInit) | null | Headers,\n): HeadersObject {\n  if (!headers) {\n    return {};\n  }\n\n  const headersObject: HeadersObject = {};\n\n  // Handle Headers object with entries() method\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n  } else if (isObject(headers)) {\n    // Handle plain object\n    for (const [key, value] of Object.entries(headers)) {\n      // Normalize keys to lowercase as per RFC 2616 4.2\n      // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n      headersObject[key.toLowerCase()] = value;\n    }\n  }\n\n  return headersObject;\n}\n","import { ABORT_ERROR, TIMEOUT_ERROR } from './constants';\nimport type { RequestConfig } from './types';\nimport type { QueueItem, RequestsQueue } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: RequestsQueue = new Map<RequestConfig, QueueItem>();\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {RequestConfig} config - The request configuration object.\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} isTimeoutEnabled - Whether timeout is enabled.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function addRequest(\n  config: RequestConfig,\n  timeout: number | undefined,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  isTimeoutEnabled: boolean = true,\n): Promise<AbortController> {\n  const now = Date.now();\n  const item = queue.get(config);\n\n  if (item) {\n    const isCancellable = item[3];\n    const previousController = item[0];\n    const timeoutId = item[1];\n\n    // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n    if (!isCancellable && now - item[2] < dedupeTime) {\n      return previousController;\n    }\n\n    // If the request is too old, remove it and proceed to add a new one\n    // Abort previous request, if applicable, and continue as usual\n    if (isCancellable) {\n      previousController.abort(\n        new DOMException('Aborted due to new request', ABORT_ERROR),\n      );\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n\n  const controller = new AbortController();\n\n  const timeoutId = isTimeoutEnabled\n    ? setTimeout(() => {\n        const error = new DOMException(\n          `${config.url} aborted due to timeout`,\n          TIMEOUT_ERROR,\n        );\n\n        removeRequest(config, error);\n      }, timeout)\n    : null;\n\n  queue.set(config, [controller, timeoutId, now, isCancellable]);\n\n  return controller;\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param config - The request configuration.\n * @param {boolean} error - Error payload so to force the request to abort.\n */\nexport async function removeRequest(\n  config: RequestConfig,\n  error: DOMException | null | string = null,\n): Promise<void> {\n  const item = queue.get(config);\n\n  if (item) {\n    const controller = item[0];\n    const timeoutId = item[1];\n\n    // If the request is not yet aborted, abort it with the provided error\n    if (error && !controller.signal.aborted) {\n      controller.abort(error);\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n}\n\n/**\n * Gets the AbortController for a request configuration.\n *\n * @param config - The request configuration.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  config: RequestConfig,\n): Promise<AbortController | undefined> {\n  const item = queue.get(config);\n\n  return item?.[0];\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  APPLICATION_CONTENT_TYPE,\n  APPLICATION_JSON,\n  CONTENT_TYPE,\n} from './constants';\nimport type { DefaultResponse, FetchResponse } from './types/request-handler';\n\n/**\n * Parses the response data based on the Content-Type header.\n *\n * @param response - The Response object to parse.\n * @returns A Promise that resolves to the parsed data.\n */\nexport async function parseResponseData<ResponseData = DefaultResponse>(\n  response: FetchResponse<ResponseData>,\n): Promise<any> {\n  // Bail early when body is empty\n  if (!response?.body) {\n    return null;\n  }\n\n  const contentType = String(\n    (response as Response).headers?.get(CONTENT_TYPE) || '',\n  ).split(';')[0]; // Correctly handle charset\n\n  let data;\n\n  try {\n    if (\n      contentType.includes(APPLICATION_JSON) ||\n      contentType.includes('+json')\n    ) {\n      data = await response.json(); // Parse JSON response\n    } else if (contentType.includes('multipart/form-data')) {\n      data = await response.formData(); // Parse as FormData\n    } else if (\n      contentType.includes(APPLICATION_CONTENT_TYPE + 'octet-stream')\n    ) {\n      data = await response.blob(); // Parse as blob\n    } else if (\n      contentType.includes(APPLICATION_CONTENT_TYPE + 'x-www-form-urlencoded')\n    ) {\n      data = await response.formData(); // Handle URL-encoded forms\n    } else if (contentType.includes('text/')) {\n      data = await response.text(); // Parse as text\n    } else {\n      try {\n        const responseClone = response.clone();\n\n        // Handle edge case of no content type being provided... We assume JSON here.\n        data = await responseClone.json();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_e) {\n        // Handle streams\n        data = await response.text();\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_error) {\n    // Parsing failed, fallback to null\n    data = null;\n  }\n\n  return data;\n}\n","const PRIME_MULTIPLIER = 31;\n\n/**\n * Computes a hash value for a given string using the variant of djb2 hash function.\n * This hash function is non-cryptographic and designed for speed.\n * @author Daniel J. Bernstein (of djb2)\n *\n * @param str Input string to hash\n * @returns {string} Hash\n */\nexport function hash(str: string): string {\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash * PRIME_MULTIPLIER + char) | 0;\n  }\n\n  return String(hash);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hash } from './hash';\nimport { fetchf } from './index';\nimport type { FetcherConfig } from './types/request-handler';\nimport type { CacheEntry } from './types/cache-manager';\nimport { GET, OBJECT, UNDEFINED } from './constants';\nimport { shallowSerialize, sortObject } from './utils';\n\nconst cache = new Map<string, CacheEntry<any>>();\n\n/**\n * Generates a cache key for a given URL and fetch options, ensuring that key factors\n * like method, headers, body, and other options are included in the cache key.\n * Headers and other objects are sorted by key to ensure consistent cache keys.\n *\n * @param options - The fetch options that may affect the request. The most important are:\n *   @property {string} [method=\"GET\"] - The HTTP method (GET, POST, etc.).\n *   @property {HeadersInit} [headers={}] - The request headers.\n *   @property {BodyInit | null} [body=\"\"] - The body of the request (only for methods like POST, PUT).\n *   @property {RequestMode} [mode=\"cors\"] - The mode for the request (e.g., cors, no-cors, include).\n *   @property {RequestCredentials} [credentials=\"include\"] - Whether to include credentials like cookies.\n *   @property {RequestCache} [cache=\"default\"] - The cache mode (e.g., default, no-store, reload).\n *   @property {RequestRedirect} [redirect=\"follow\"] - How to handle redirects (e.g., follow, error, manual).\n *   @property {string} [referrer=\"\"] - The referrer URL to send with the request.\n *   @property {string} [integrity=\"\"] - Subresource integrity value (a cryptographic hash for resource validation).\n * @returns {string} - A unique cache key based on the URL and request options. Empty if cache is to be burst.\n *\n * @example\n * const cacheKey = generateCacheKey({\n *   url: 'https://api.example.com/data',\n *   method: 'POST',\n *   headers: { 'Content-Type': 'application/json' },\n *   body: JSON.stringify({ name: 'Alice' }),\n *   mode: 'cors',\n *   credentials: 'include',\n * });\n * console.log(cacheKey);\n */\nexport function generateCacheKey(options: FetcherConfig): string {\n  const {\n    url = '',\n    method = GET,\n    headers = {},\n    body = '',\n    mode = 'cors',\n    credentials = 'include',\n    cache = 'default',\n    redirect = 'follow',\n    referrer = '',\n    integrity = '',\n  } = options;\n\n  // Bail early if cache should be burst\n  if (cache === 'reload') {\n    return '';\n  }\n\n  // Sort headers and body + convert sorted to strings for hashing purposes\n  // Native serializer is on avg. 3.5x faster than a Fast Hash or FNV-1a\n  const headersString = shallowSerialize(sortObject(headers));\n\n  let bodyString = '';\n\n  // In majority of cases we do not cache body\n  if (body !== null) {\n    if (typeof body === 'string') {\n      bodyString = hash(body);\n    } else if (body instanceof FormData) {\n      body.forEach((value, key) => {\n        // Append key=value and '&' directly to the result\n        bodyString += key + '=' + value + '&';\n      });\n      bodyString = hash(bodyString);\n    } else if (\n      (typeof Blob !== UNDEFINED && body instanceof Blob) ||\n      (typeof File !== UNDEFINED && body instanceof File)\n    ) {\n      bodyString = 'BF' + body.size + body.type;\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      bodyString = 'AB' + body.byteLength;\n    } else {\n      const o = typeof body === OBJECT ? sortObject(body) : String(body);\n      bodyString = hash(JSON.stringify(o));\n    }\n  }\n\n  // Concatenate all key parts into a cache key string\n  // Template literals are apparently slower\n  return (\n    method +\n    url +\n    mode +\n    credentials +\n    cache +\n    redirect +\n    referrer +\n    integrity +\n    headersString +\n    bodyString\n  ).replace(/[^\\w-_]/g, ''); // Prevent cache poisoning by removal of anything that isn't letters, numbers, - or _\n}\n\n/**\n * Checks if the cache entry is expired based on its timestamp and the maximum stale time.\n *\n * @param {number} timestamp - The timestamp of the cache entry.\n * @param {number} maxStaleTime - The maximum stale time in seconds.\n * @returns {boolean} - Returns true if the cache entry is expired, false otherwise.\n */\nfunction isCacheExpired(timestamp: number, maxStaleTime: number): boolean {\n  if (!maxStaleTime) {\n    return false;\n  }\n\n  return Date.now() - timestamp > maxStaleTime * 1000;\n}\n\n/**\n * Retrieves a cache entry if it exists and is not expired.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} cacheTime - Maximum time to cache entry.\n * @returns {CacheEntry<T> | null} - The cache entry if it exists and is not expired, null otherwise.\n */\nexport function getCache<T>(\n  key: string,\n  cacheTime: number,\n): CacheEntry<T> | null {\n  const entry = cache.get(key);\n\n  if (entry) {\n    if (!isCacheExpired(entry.timestamp, cacheTime)) {\n      return entry;\n    }\n\n    cache.delete(key);\n  }\n\n  return null;\n}\n\n/**\n * Sets a new cache entry or updates an existing one.\n *\n * @param {string} key Cache key to utilize\n * @param {T} data - The data to be cached.\n * @param {boolean} isLoading - Indicates if the data is currently being fetched.\n */\nexport function setCache<T = unknown>(\n  key: string,\n  data: T,\n  isLoading: boolean = false,\n): void {\n  cache.set(key, {\n    data,\n    isLoading,\n    timestamp: Date.now(),\n  });\n}\n\n/**\n * Revalidates a cache entry by fetching fresh data and updating the cache.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @returns {Promise<void>} - A promise that resolves when the revalidation is complete.\n */\nexport async function revalidate(\n  key: string,\n  config: FetcherConfig,\n): Promise<void> {\n  try {\n    // Fetch fresh data\n    const newData = await fetchf(config.url, {\n      ...config,\n      cache: 'reload',\n    });\n\n    setCache(key, newData);\n  } catch (error) {\n    console.error(`Error revalidating ${config.url}:`, error);\n\n    // Rethrow the error to forward it\n    throw error;\n  }\n}\n\n/**\n * Invalidates (deletes) a cache entry.\n *\n * @param {string} key Cache key to utilize\n */\nexport function deleteCache(key: string): void {\n  cache.delete(key);\n}\n\n/**\n * Mutates a cache entry with new data and optionally revalidates it.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @param {T} newData - The new data to be cached.\n * @param {boolean} revalidateAfter - If true, triggers revalidation after mutation.\n */\nexport function mutate<T>(\n  key: string,\n  config: FetcherConfig,\n  newData: T,\n  revalidateAfter: boolean = false,\n): void {\n  setCache(key, newData);\n\n  if (revalidateAfter) {\n    revalidate(key, config);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  DefaultResponse,\n  RequestHandlerConfig,\n  RequestConfig,\n  Method,\n  RetryOptions,\n  FetchResponse,\n  RequestHandlerReturnType,\n  CreatedCustomFetcherInstance,\n  FetcherConfig,\n  FetcherInstance,\n  Logger,\n  HeadersObject,\n} from './types/request-handler';\nimport type {\n  BodyPayload,\n  DefaultParams,\n  DefaultPayload,\n  DefaultUrlParams,\n  QueryParams,\n} from './types/api-handler';\nimport { applyInterceptor } from './interceptor-manager';\nimport { ResponseError } from './errors/response-error';\nimport {\n  appendQueryParams,\n  isJSONSerializable,\n  replaceUrlPathParams,\n  delayInvocation,\n  flattenData,\n  processHeaders,\n  isSearchParams,\n  sanitizeObject,\n} from './utils';\nimport { addRequest, removeRequest } from './queue-manager';\nimport {\n  ABORT_ERROR,\n  APPLICATION_JSON,\n  CANCELLED_ERROR,\n  CHARSET_UTF_8,\n  CONTENT_TYPE,\n  FUNCTION,\n  GET,\n  HEAD,\n  OBJECT,\n  STRING,\n  UNDEFINED,\n} from './constants';\nimport { parseResponseData } from './response-parser';\nimport { generateCacheKey, getCache, setCache } from './cache-manager';\n\nconst defaultConfig: RequestHandlerConfig = {\n  method: GET,\n  strategy: 'reject',\n  timeout: 30000,\n  dedupeTime: 1000,\n  defaultResponse: null,\n  headers: {\n    Accept: APPLICATION_JSON + ', text/plain, */*',\n    'Accept-Encoding': 'gzip, deflate, br',\n  },\n  retry: {\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n  },\n};\n\n/**\n * Create Request Handler\n *\n * @param {RequestHandlerConfig} config - Configuration object for the request handler\n * @returns {Object} An object with methods for handling requests\n */\nexport function createRequestHandler(\n  config: RequestHandlerConfig,\n): RequestHandlerReturnType {\n  const sanitizedConfig = sanitizeObject(config);\n  const handlerConfig: RequestHandlerConfig = {\n    ...defaultConfig,\n    ...sanitizedConfig,\n  };\n\n  /**\n   * Merges the specified property from the base configuration and the new configuration into the target configuration.\n   *\n   * @param {K} property - The property key to merge from the base and new configurations. Must be a key of RequestHandlerConfig.\n   * @param {RequestHandlerConfig} targetConfig - The configuration object that will receive the merged properties.\n   * @param {RequestHandlerConfig} baseConfig - The base configuration object that provides default values.\n   * @param {RequestHandlerConfig} newConfig - The new configuration object that contains user-specific settings to merge.\n   */\n  const mergeConfig = <K extends keyof RequestHandlerConfig>(\n    property: K,\n    targetConfig: RequestHandlerConfig,\n    baseConfig: RequestHandlerConfig,\n    newConfig: RequestHandlerConfig,\n  ) => {\n    if (newConfig[property]) {\n      targetConfig[property] = {\n        ...baseConfig[property],\n        ...newConfig[property],\n      };\n    }\n  };\n\n  mergeConfig('retry', handlerConfig, defaultConfig, sanitizedConfig);\n  mergeConfig('headers', handlerConfig, defaultConfig, sanitizedConfig);\n\n  /**\n   * Gets a configuration value from `reqConfig`, defaulting to `handlerConfig` if not present.\n   *\n   * @param {RequestConfig} reqConfig - Request configuration object.\n   * @param {keyof RequestConfig} name - Key of the configuration value.\n   * @returns {T} - The configuration value.\n   */\n  const getConfig = <T = unknown>(\n    reqConfig: RequestConfig,\n    name: keyof RequestConfig,\n  ): T => {\n    return typeof reqConfig[name] !== UNDEFINED\n      ? reqConfig[name]\n      : handlerConfig[name];\n  };\n\n  /**\n   * Immediately create instance of custom fetcher if it is defined\n   */\n  const customFetcher = getConfig<FetcherInstance>(sanitizedConfig, 'fetcher');\n  const requestInstance = customFetcher?.create(handlerConfig) || null;\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Provider's instance\n   */\n  const getInstance = (): CreatedCustomFetcherInstance | null => {\n    return requestInstance;\n  };\n\n  /**\n   * Logs messages or errors using the configured logger's `warn` method.\n   *\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @param {...(string | ResponseError<any>)} args - Messages or errors to log.\n   */\n  const logger = (\n    reqConfig: RequestConfig,\n    ...args: (string | ResponseError<any>)[]\n  ): void => {\n    const logger = getConfig<Logger>(reqConfig, 'logger');\n\n    if (logger?.warn) {\n      logger.warn(...args);\n    }\n  };\n\n  /**\n   * Ensures the `Content-Type` header is set to `application/json; charset=utf-8`\n   * if it is not already present and the request method and body meet specific conditions.\n   *\n   * @param headers - The headers object to modify. Can be an instance of `Headers`\n   *                  or a plain object conforming to `HeadersInit`.\n   * @param method - The HTTP method of the request (e.g., 'PUT', 'DELETE', etc.).\n   * @param body - The optional body of the request. If no body is provided and the\n   *               method is 'PUT' or 'DELETE', the function exits without modifying headers.\n   */\n  const setContentTypeIfNeeded = (\n    headers: HeadersInit,\n    method: string,\n    body?: unknown,\n  ): void => {\n    if (!body && ['PUT', 'DELETE'].includes(method)) {\n      return;\n    }\n\n    const contentTypeValue = APPLICATION_JSON + ';' + CHARSET_UTF_8;\n\n    if (headers instanceof Headers) {\n      if (!headers.has(CONTENT_TYPE)) {\n        headers.set(CONTENT_TYPE, contentTypeValue);\n      }\n    } else if (\n      typeof headers === OBJECT &&\n      !Array.isArray(headers) &&\n      !headers[CONTENT_TYPE]\n    ) {\n      headers[CONTENT_TYPE] = contentTypeValue;\n    }\n  };\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url - Request url\n   * @param {RequestConfig} requestConfig - Request config passed when making the request\n   * @returns {RequestConfig} - Provider's instance\n   */\n  const buildConfig = (\n    url: string,\n    requestConfig: RequestConfig,\n  ): FetcherConfig => {\n    const method = getConfig<string>(\n      requestConfig,\n      'method',\n    ).toUpperCase() as Method;\n    const isGetAlikeMethod = method === GET || method === HEAD;\n\n    const dynamicUrl = replaceUrlPathParams(\n      url,\n      getConfig(requestConfig, 'urlPathParams'),\n    );\n\n    // The explicitly passed \"params\"\n    const explicitParams = getConfig<QueryParams>(requestConfig, 'params');\n\n    // The explicitly passed \"body\" or \"data\"\n    const explicitBodyData: BodyPayload =\n      getConfig(requestConfig, 'body') || getConfig(requestConfig, 'data');\n\n    // Final body data\n    let body: RequestConfig['data'];\n\n    // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n    if (!isGetAlikeMethod) {\n      body = explicitBodyData;\n    }\n\n    const headers = getConfig<HeadersObject>(requestConfig, 'headers');\n\n    setContentTypeIfNeeded(headers, method, body);\n\n    // Native fetch compatible settings\n    const isWithCredentials = getConfig<boolean>(\n      requestConfig,\n      'withCredentials',\n    );\n\n    const credentials = isWithCredentials\n      ? 'include'\n      : getConfig<RequestCredentials>(requestConfig, 'credentials');\n\n    const urlPath = explicitParams\n      ? appendQueryParams(dynamicUrl, explicitParams)\n      : dynamicUrl;\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl\n      ? ''\n      : getConfig<string>(requestConfig, 'baseURL') ||\n        getConfig<string>(requestConfig, 'apiUrl');\n\n    // Automatically stringify request body, if possible and when not dealing with strings\n    if (\n      body &&\n      typeof body !== STRING &&\n      !isSearchParams(body) &&\n      isJSONSerializable(body)\n    ) {\n      body = JSON.stringify(body);\n    }\n\n    return {\n      ...requestConfig,\n      credentials,\n      body,\n      method,\n      headers,\n      url: baseURL + urlPath,\n    };\n  };\n\n  /**\n   * Process global Request Error\n   *\n   * @param {ResponseError<ResponseData, QueryParams, PathParams, RequestBody>} error      Error instance\n   * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} requestConfig   Per endpoint request config\n   * @returns {Promise<void>}\n   */\n  const processError = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    error: ResponseError<ResponseData, QueryParams, PathParams, RequestBody>,\n    requestConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    >,\n  ): Promise<void> => {\n    if (!isRequestCancelled(error as ResponseError)) {\n      logger(requestConfig, 'API ERROR', error as ResponseError);\n    }\n\n    // Local interceptors\n    await applyInterceptor(error, requestConfig?.onError);\n\n    // Global interceptors\n    await applyInterceptor(error, handlerConfig?.onError);\n  };\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {ResponseError<ResponseData, QueryParams, PathParams, RequestBody>} error - Error instance\n   * @param {FetchResponse<ResponseData, RequestBody> | null} response - Response. It may be \"null\" in case of request being aborted.\n   * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} requestConfig - Per endpoint request config\n   * @returns {FetchResponse<ResponseData, RequestBody>} Response together with the error object\n   */\n  const outputErrorResponse = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    error: ResponseError<ResponseData, QueryParams, PathParams, RequestBody>,\n    response: FetchResponse<ResponseData, RequestBody> | null,\n    requestConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    >,\n  ): Promise<any> => {\n    const _isRequestCancelled = isRequestCancelled(error as ResponseError);\n    const errorHandlingStrategy = getConfig<string>(requestConfig, 'strategy');\n    const rejectCancelled = getConfig<boolean>(\n      requestConfig,\n      'rejectCancelled',\n    );\n\n    // By default cancelled requests aren't rejected (softFail strategy)\n    if (!(_isRequestCancelled && !rejectCancelled)) {\n      // Hang the promise\n      if (errorHandlingStrategy === 'silent') {\n        await new Promise(() => null);\n      }\n      // Reject the promise\n      else if (errorHandlingStrategy === 'reject') {\n        return Promise.reject(error);\n      }\n    }\n\n    return outputResponse<ResponseData, QueryParams, PathParams, RequestBody>(\n      response,\n      requestConfig,\n      error,\n    );\n  };\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {ResponseError} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  const isRequestCancelled = (error: ResponseError): boolean => {\n    return error.name === ABORT_ERROR || error.name === CANCELLED_ERROR;\n  };\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @throws {ResponseError}\n   * @returns {Promise<FetchResponse<ResponseData>>} Response Data\n   */\n  const request = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    url: string,\n    reqConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    > | null = null,\n  ): Promise<FetchResponse<ResponseData, RequestBody>> => {\n    const _reqConfig = sanitizeObject(reqConfig || {});\n    const mergedConfig = {\n      ...handlerConfig,\n      ..._reqConfig,\n    };\n\n    mergeConfig('retry', mergedConfig, handlerConfig, _reqConfig);\n    mergeConfig('headers', mergedConfig, handlerConfig, _reqConfig);\n\n    let response: FetchResponse<ResponseData> | null = null;\n    const fetcherConfig = buildConfig(url, mergedConfig);\n\n    const {\n      timeout,\n      cancellable,\n      dedupeTime,\n      pollingInterval,\n      shouldStopPolling,\n      cacheTime,\n      cacheKey,\n    } = mergedConfig;\n\n    // Prevent performance overhead of cache access\n    let _cacheKey: string;\n\n    if (cacheKey) {\n      _cacheKey = cacheKey(fetcherConfig);\n    } else {\n      _cacheKey = generateCacheKey(fetcherConfig);\n    }\n\n    if (cacheTime && _cacheKey) {\n      const cacheBuster = mergedConfig.cacheBuster;\n\n      if (!cacheBuster || !cacheBuster(fetcherConfig)) {\n        const cachedEntry = getCache<FetchResponse<ResponseData>>(\n          _cacheKey,\n          cacheTime,\n        );\n\n        if (cachedEntry) {\n          // Serve stale data from cache\n          return cachedEntry.data;\n        }\n      }\n    }\n\n    const {\n      retries = 0,\n      delay,\n      backoff,\n      retryOn,\n      shouldRetry,\n      maxDelay,\n      resetTimeout,\n    } = mergedConfig.retry as Required<\n      RetryOptions<ResponseData, QueryParams, PathParams, RequestBody>\n    >;\n\n    let attempt = 0;\n    let pollingAttempt = 0;\n    let waitTime: number = delay;\n    const _retries = retries > 0 ? retries : 0;\n\n    while (attempt <= _retries) {\n      try {\n        // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n        const controller = await addRequest(\n          fetcherConfig,\n          timeout,\n          dedupeTime,\n          cancellable,\n          // Reset timeouts by default or when retries are ON\n          !!(timeout && (!_retries || resetTimeout)),\n        );\n\n        // Shallow copy to ensure basic idempotency\n        // Note that the refrence of the main object does not change here so it is safe in context of queue management and interceptors\n        const requestConfig: RequestConfig = {\n          signal: controller.signal,\n          ...fetcherConfig,\n        };\n\n        // Local interceptors\n        await applyInterceptor(requestConfig, _reqConfig?.onRequest);\n\n        // Global interceptors\n        await applyInterceptor(requestConfig, handlerConfig?.onRequest);\n\n        if (\n          customFetcher !== null &&\n          requestInstance !== null &&\n          typeof requestInstance.request === FUNCTION\n        ) {\n          response = await requestInstance.request(requestConfig);\n        } else {\n          response = (await fetch(\n            requestConfig.url as string,\n            requestConfig as RequestInit,\n          )) as unknown as FetchResponse<ResponseData, RequestBody>;\n        }\n\n        // Add more information to response object\n        if (response instanceof Response) {\n          response.config = requestConfig;\n          response.data = await parseResponseData(response);\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseError<\n              ResponseData,\n              QueryParams,\n              PathParams,\n              RequestBody\n            >(\n              `${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        await applyInterceptor(response, _reqConfig?.onResponse);\n\n        // Global interceptors\n        await applyInterceptor(response, handlerConfig?.onResponse);\n\n        removeRequest(fetcherConfig);\n\n        if (\n          shouldRetry &&\n          attempt < retries &&\n          (await shouldRetry(\n            { config: fetcherConfig, request: fetcherConfig, response },\n            attempt,\n          ))\n        ) {\n          logger(\n            mergedConfig,\n            `Attempt ${attempt + 1} failed response data check. Retry in ${waitTime}ms.`,\n          );\n\n          await delayInvocation(waitTime);\n\n          waitTime *= backoff;\n          waitTime = Math.min(waitTime, maxDelay);\n          attempt++;\n          continue; // Retry the request\n        }\n\n        // Polling logic\n        if (\n          pollingInterval &&\n          (!shouldStopPolling || !shouldStopPolling(response, pollingAttempt))\n        ) {\n          // Restart the main retry loop\n          pollingAttempt++;\n\n          logger(requestConfig, 'Polling attempt ' + pollingAttempt + '...');\n\n          await delayInvocation(pollingInterval);\n\n          continue;\n        }\n\n        // If polling is not required, or polling attempts are exhausted\n        const output = outputResponse<\n          ResponseData,\n          QueryParams,\n          PathParams,\n          RequestBody\n        >(response, requestConfig);\n\n        if (cacheTime && _cacheKey) {\n          const skipCache = requestConfig.skipCache;\n\n          if (!skipCache || !skipCache(output, requestConfig)) {\n            setCache(_cacheKey, output);\n          }\n        }\n\n        return output;\n      } catch (err) {\n        const error = err as ResponseError<\n          ResponseData,\n          QueryParams,\n          PathParams,\n          RequestBody\n        >;\n\n        // Append additional information to Network, CORS or any other fetch() errors\n        error.status = error?.status || response?.status || 0;\n        error.statusText = error?.statusText || response?.statusText || '';\n        error.config = fetcherConfig;\n        error.request = fetcherConfig;\n        error.response = response;\n\n        if (\n          // We check retries provided regardless of the shouldRetry being provided so to avoid infinite loops.\n          // It is a fail-safe so to prevent excessive retry attempts even if custom retry logic suggests a retry.\n          attempt === retries || // Stop if the maximum retries have been reached\n          !retryOn?.includes(error.status) || // Check if the error status is retryable\n          !(await shouldRetry?.(error, attempt)) // If shouldRetry is defined, evaluate it\n        ) {\n          await processError<\n            ResponseData,\n            QueryParams,\n            PathParams,\n            RequestBody\n          >(error, fetcherConfig);\n\n          removeRequest(fetcherConfig);\n\n          return outputErrorResponse<\n            ResponseData,\n            QueryParams,\n            PathParams,\n            RequestBody\n          >(error, response, fetcherConfig);\n        }\n\n        logger(\n          mergedConfig,\n          `Attempt ${attempt + 1} failed. Retry in ${waitTime}ms.`,\n        );\n\n        await delayInvocation(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return outputResponse<ResponseData, QueryParams, PathParams, RequestBody>(\n      response,\n      fetcherConfig,\n    );\n  };\n\n  /**\n   * Output response\n   *\n   * @param Response. It may be \"null\" in case of request being aborted.\n   * @param {RequestConfig} requestConfig - Request config\n   * @param error - whether the response is erroneous\n   * @returns {FetchResponse<ResponseData>} Response data\n   */\n  const outputResponse = <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    response: FetchResponse<ResponseData, RequestBody> | null,\n    requestConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    >,\n    error: ResponseError<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    > | null = null,\n  ): FetchResponse<ResponseData, RequestBody> => {\n    const defaultResponse = getConfig<any>(requestConfig, 'defaultResponse');\n\n    // This may happen when request is cancelled.\n    if (!response) {\n      return {\n        ok: false,\n        // Enhance the response with extra information\n        error,\n        data: defaultResponse,\n        headers: null,\n        config: requestConfig,\n      } as unknown as FetchResponse<ResponseData>;\n    }\n\n    let data = response?.data;\n\n    // Set the default response if the provided data is an empty object\n    if (\n      data === undefined ||\n      data === null ||\n      (typeof data === OBJECT && Object.keys(data).length === 0)\n    ) {\n      data = defaultResponse;\n    }\n\n    // Return flattened response immediately\n    const flattenResponse = getConfig<boolean>(\n      requestConfig,\n      'flattenResponse',\n    );\n\n    if (flattenResponse) {\n      response.data = flattenData(data);\n    }\n\n    // If it's a custom fetcher, and it does not return any Response instance, it may have its own internal handler\n    if (!(response instanceof Response)) {\n      return response;\n    }\n\n    // Native fetch Response extended by extra information\n    return {\n      body: response.body,\n      bodyUsed: response.bodyUsed,\n      ok: response.ok,\n      redirected: response.redirected,\n      type: response.type,\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n\n      // Convert methods to use arrow functions to preserve correct return types\n      blob: () => response.blob(),\n      json: () => response.json(),\n      text: () => response.text(),\n      clone: () => response.clone(),\n      arrayBuffer: () => response.arrayBuffer(),\n      formData: () => response.formData(),\n      bytes: () => response.bytes(),\n\n      // Enhance the response with extra information\n      error,\n      data,\n      headers: processHeaders(response.headers),\n      config: requestConfig,\n    };\n  };\n\n  return {\n    getInstance,\n    buildConfig,\n    config: handlerConfig,\n    request,\n  };\n}\n","import type {\n  RequestConfig,\n  FetchResponse,\n  DefaultResponse,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerDefaultMethods,\n  ApiHandlerMethods,\n  DefaultPayload,\n  FallbackValue,\n  FinalParams,\n  FinalResponse,\n  QueryParams,\n  RequestConfigUrlRequired,\n  UrlPathParams,\n} from './types/api-handler';\nimport { createRequestHandler } from './request-handler';\nimport { fetchf } from '.';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n * @url https://github.com/MattCCC/fetchff\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the ongoing previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {number} config.dedupeTime - Time window, in milliseconds, during which identical requests are deduplicated (treated as single request).\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\". It works only if the response structure includes a single data property.\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsSettings = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = createRequestHandler(config);\n\n  /**\n   * Get Custom Fetcher Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Request Handler's Custom Fetcher Instance\n   */\n  function getInstance(): CreatedCustomFetcherInstance | null {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`Add ${endpointName} to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {keyof EndpointsMethods | string} endpointName - The name of the API endpoint to call.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<FetchResponse<ResponseData>>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<\n    ResponseData = never,\n    QueryParams_ = never,\n    UrlParams = never,\n    RequestBody = never,\n  >(\n    endpointName: keyof EndpointsMethods | string,\n    requestConfig: RequestConfig<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlPathParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    > = {},\n  ): Promise<FetchResponse<FinalResponse<ResponseData, DefaultResponse>>> {\n    // Use global per-endpoint settings\n    const endpointConfig =\n      endpoints[endpointName] ||\n      ({ url: String(endpointName) } as RequestConfigUrlRequired);\n    const url = endpointConfig.url;\n\n    // Block Protocol-relative URLs as they could lead to SSRF (Server-Side Request Forgery)\n    if (url.startsWith('//')) {\n      throw new Error('Protocol-relative URLs are not allowed.');\n    }\n\n    // Prevent potential Server-Side Request Forgery attack and leakage of credentials when same instance is used for external requests\n    const isAbsoluteUrl = url.includes('://');\n\n    if (isAbsoluteUrl) {\n      // Retrigger fetch to ensure completely new instance of handler being triggered for external URLs\n      return await fetchf(url, requestConfig);\n    }\n\n    const responseData = await requestHandler.request<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    >(url, {\n      ...endpointConfig,\n      ...requestConfig,\n    });\n\n    return responseData;\n  }\n\n  const apiHandler: ApiHandlerDefaultMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  return new Proxy<ApiHandlerMethods<EndpointsMethods, EndpointsSettings>>(\n    apiHandler as ApiHandlerMethods<EndpointsMethods, EndpointsSettings>,\n    {\n      get(_target, prop: string) {\n        if (prop in apiHandler) {\n          return apiHandler[prop as unknown as keyof typeof apiHandler];\n        }\n\n        // Prevent handler from triggering non-existent endpoints\n        if (endpoints[prop]) {\n          return apiHandler.request.bind(null, prop);\n        }\n\n        return handleNonImplemented.bind(null, prop);\n      },\n    },\n  );\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["index_exports","__export","createApiFetcher","fetchf","applyInterceptor","object","interceptors","value","interceptor","FetchError","message","request","response","__publicField","ResponseError","FetchError","message","request","response","APPLICATION_CONTENT_TYPE","APPLICATION_JSON","CHARSET_UTF_8","CONTENT_TYPE","UNDEFINED","OBJECT","STRING","FUNCTION","ABORT_ERROR","TIMEOUT_ERROR","CANCELLED_ERROR","GET","HEAD","MAX_DEPTH","dangerousProps","isSearchParams","data","isObject","value","OBJECT","shallowSerialize","obj","result","key","sanitizeObject","safeObj","prop","sortObject","sortedObj","keys","i","len","appendQueryStringToUrl","baseUrl","queryString","appendQueryParams","url","params","encodedQueryString","s","encode","add","k","v","FUNCTION","buildParams","prefix","depth","replaceUrlPathParams","urlPathParams","str","word","isJSONSerializable","UNDEFINED","STRING","delayInvocation","ms","resolve","flattenData","processHeaders","headers","headersObject","queue","addRequest","config","timeout","dedupeTime","isCancellable","isTimeoutEnabled","now","item","previousController","timeoutId","ABORT_ERROR","controller","error","TIMEOUT_ERROR","removeRequest","parseResponseData","response","_a","contentType","CONTENT_TYPE","data","APPLICATION_JSON","APPLICATION_CONTENT_TYPE","_e","_error","hash","str","i","len","char","cache","generateCacheKey","options","url","method","GET","headers","body","mode","credentials","redirect","referrer","integrity","headersString","shallowSerialize","sortObject","bodyString","hash","value","key","UNDEFINED","o","OBJECT","isCacheExpired","timestamp","maxStaleTime","getCache","cacheTime","entry","setCache","data","isLoading","defaultConfig","GET","APPLICATION_JSON","createRequestHandler","config","sanitizedConfig","sanitizeObject","handlerConfig","mergeConfig","property","targetConfig","baseConfig","newConfig","getConfig","reqConfig","name","UNDEFINED","customFetcher","requestInstance","getInstance","logger","args","setContentTypeIfNeeded","headers","method","body","contentTypeValue","CHARSET_UTF_8","CONTENT_TYPE","OBJECT","buildConfig","url","requestConfig","isGetAlikeMethod","HEAD","dynamicUrl","replaceUrlPathParams","explicitParams","explicitBodyData","credentials","urlPath","appendQueryParams","baseURL","STRING","isSearchParams","isJSONSerializable","processError","error","isRequestCancelled","applyInterceptor","outputErrorResponse","response","_isRequestCancelled","errorHandlingStrategy","rejectCancelled","outputResponse","ABORT_ERROR","CANCELLED_ERROR","request","_reqConfig","mergedConfig","fetcherConfig","timeout","cancellable","dedupeTime","pollingInterval","shouldStopPolling","cacheTime","cacheKey","_cacheKey","generateCacheKey","cacheBuster","cachedEntry","getCache","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","pollingAttempt","waitTime","_retries","addRequest","FUNCTION","parseResponseData","ResponseError","removeRequest","delayInvocation","output","skipCache","setCache","err","defaultResponse","data","flattenData","processHeaders","createApiFetcher","config","endpoints","requestHandler","createRequestHandler","getInstance","handleNonImplemented","endpointName","request","requestConfig","endpointConfig","url","fetchf","apiHandler","_target","prop","fetchf","url","config","createRequestHandler"]}