{"version":3,"sources":["../../src/react/cache-ref.ts","../../src/react/index.ts"],"names":["INFINITE_CACHE_TIME","DEFAULT_DEDUPE_TIME_MS","refs","incrementRef","key","decrementRef","cacheTime","dedupeTime","url","current","getRefCount","newCount","addTimeout","abortRequest","deleteCache","DEFAULT_STALE_TIME","DEFAULT_RESULT","FETCHING_RESULT","DEFAULT_REF","SAFE_METHODS","useFetcher","config","_a","_b","_c","cacheKey","useMemo","generateCacheKey","buildConfig","staleTime","shouldTriggerOnMount","currentValuesRef","useRef","getSnapshot","useCallback","cached","getCache","pendingPromise","getInFlightPromise","currUrl","currConfig","currCacheKey","fetchf","doSubscribe","cb","getCachedResponse","refetch","unsubscribe","subscribe","state","useSyncExternalStore","forceRefresh","requestConfig","shouldRefresh","cacheBuster","data","isUnresolved","isFetching","isLoading"],"mappings":"0NAgBO,IAAMA,CAAAA,CAAsB,EACtBC,CAAAA,CAAAA,CAAyB,GAEhCC,CAAAA,CAAAA,CAAO,IAAI,GAAA,CAEJC,CAAgBC,CAAAA,CAAAA,EAAuB,CAC9CA,CAAAA,EACFF,CAAK,CAAA,GAAA,CAAIE,GAAMF,CAAK,CAAA,GAAA,CAAIE,CAAG,CAAA,EAAK,CAAK,EAAA,CAAC,EAE1C,CAAA,CAEaC,EAAe,CAC1BD,CAAAA,CACAE,CACAC,CAAAA,CAAAA,CACAC,CACG,GAAA,CACH,GAAI,CAACJ,EACH,OAGF,IAAMK,CAAUC,CAAAA,CAAAA,CAAYN,CAAG,CAAA,CAE/B,GAAI,CAACK,CACH,CAAA,OAGF,IAAME,CAAAA,CAAWF,CAAU,CAAA,CAAA,CAKvBE,CAAY,EAAA,CAAA,EACdT,EAAK,MAAOE,CAAAA,CAAG,CAEXE,CAAaA,CAAcN,GAAAA,CAAAA,EAE7BY,UACE,CAAA,IAAA,CAAOR,EACP,IAAM,CAEJS,YACET,CAAAA,CAAAA,CACA,IAAI,YAAA,CAAa,aAAgBI,CAAAA,CAAAA,CAAM,WAAY,YAAY,CACjE,CAMKE,CAAAA,CAAAA,CAAYN,CAAG,CAAA,EAClBU,WAAYV,CAAAA,CAAAA,CAAK,IAAI,EAEzB,CACAG,CAAAA,CAAAA,EAAA,IAAAA,CAAAA,CAAAA,CAAcN,CAChB,CAAA,EAGFC,EAAK,GAAIE,CAAAA,CAAAA,CAAKO,CAAQ,EAE1B,CAEaD,CAAAA,CAAAA,CAAeN,CACrBA,EAAAA,CAAAA,EAIEF,EAAK,GAAIE,CAAAA,CAAG,CAAK,EAAA,CAAA,CCtD1B,IAAMW,CAAAA,CAAqB,GAGrBC,CAAAA,CAAAA,CAAiB,OAAO,MAAO,CAAA,CACnC,IAAM,CAAA,IAAA,CACN,KAAO,CAAA,IAAA,CACP,UAAY,CAAA,KAAA,CACZ,MAAQ,CAAA,IAAM,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA,CAClC,MAAQ,CAAA,GACR,OAAS,CAAA,EACX,CAAC,CAEKC,CAAAA,CAAAA,CAAkB,MAAO,CAAA,MAAA,CAAO,CACpC,GAAGD,CAAAA,CACH,UAAY,CAAA,IACd,CAAC,CAAA,CAEKE,CAAc,CAAA,CAAC,KAAM,EAAC,CAAG,IAAI,CAAA,CAO7BC,CAAe,CAAA,IAAI,GAAI,CAAA,CAAC,KAAO,CAAA,MAAA,CAAQ,KAAO,CAAA,MAAM,CAAC,CAAA,CAqCpD,SAASC,EAAAA,CAMdZ,EACAa,CAKI,CAAA,EACkE,CAAA,CAvGxE,IAAAC,CAAAA,CAAAC,CAAAC,CAAAA,CAAAA,CA0GE,IAAMC,CAAWC,CAAAA,OAAAA,CACf,IAAOlB,CAAAA,GAAQ,IAAO,CAAA,IAAA,CAAOmB,gBAAiBC,CAAAA,WAAAA,CAAYpB,EAAKa,CAAM,CAAC,CACtE,CAAA,CACEA,CAAO,CAAA,QAAA,CACPb,CACAa,CAAAA,CAAAA,CAAO,GACPA,CAAAA,CAAAA,CAAO,MACPA,CAAAA,CAAAA,CAAO,OACPA,CAAAA,CAAAA,CAAO,IACPA,CAAAA,CAAAA,CAAO,OACPA,CAAO,CAAA,aAAA,CACPA,CAAO,CAAA,MAAA,CACPA,CAAO,CAAA,OAAA,CACPA,CAAO,CAAA,eAAA,CACPA,EAAO,WACT,CACF,CACMd,CAAAA,CAAAA,CAAAA,CAAae,CAAAD,CAAAA,CAAAA,CAAO,UAAP,GAAA,IAAA,CAAAC,EAAqBrB,CAClCK,CAAAA,CAAAA,CAAYe,CAAO,CAAA,SAAA,EAAarB,CAChC6B,CAAAA,CAAAA,CAAAA,CAAYN,CAAAF,CAAAA,CAAAA,CAAO,YAAP,IAAAE,CAAAA,CAAAA,CAAoBR,CAGhCe,CAAAA,CAAAA,CAAAA,CACJN,CAAAH,CAAAA,CAAAA,CAAO,SAAP,GAAA,IAAA,CAAAG,EAAoBL,CAAa,CAAA,GAAA,CAAIE,CAAO,CAAA,MAAA,EAAU,KAAK,CAAA,CAEvDU,CAAmBC,CAAAA,MAAAA,CAAOd,CAAW,CAC3Ca,CAAAA,CAAAA,CAAiB,OAAU,CAAA,CAACvB,CAAKa,CAAAA,CAAAA,CAAQI,CAAQ,CAAA,CAGjD,IAAMQ,CAAcC,CAAAA,WAAAA,CAAY,IAAM,CACpC,IAAMC,CAAAA,CAASC,QACbX,CAAAA,CACF,CAGA,CAAA,GACEJ,CAAO,CAAA,QAAA,GAAa,QACpBI,EAAAA,CAAAA,GACC,CAACU,CAAAA,EAAW,CAACA,CAAO,CAAA,IAAA,CAAK,IAAQ,EAAA,CAACA,CAAO,CAAA,IAAA,CAAK,KAC/C,CAAA,CAAA,CACA,IAAME,CAAiBC,CAAAA,kBAAAA,CAAmBb,CAAUlB,CAAAA,CAAU,CAE9D,CAAA,GAAI8B,CACF,CAAA,MAAMA,EAIR,GAAI,CAACF,CAAQ,CAAA,CACX,GAAM,CAACI,CAASC,CAAAA,CAAAA,CAAYC,CAAY,CAAA,CAAIV,CAAiB,CAAA,OAAA,CAE7D,GAAIQ,CAAAA,CAYF,MAXqBG,MAAAA,CAAOH,EAAS,CACnC,GAAGC,CACH,CAAA,QAAA,CAAUC,CACV,CAAA,UAAA,CAAAlC,CACA,CAAA,SAAA,CAAAD,EACA,SAAAuB,CAAAA,CAAAA,CACA,QAAU,CAAA,UAAA,CACV,WAAa,CAAA,IAAA,CACb,UAAY,CAAA,CAACW,EAAW,QAC1B,CAAC,CAIL,CACF,CAEA,OAAIL,CACKA,CAAAA,CAAAA,CAAO,IAAK,CAAA,UAAA,EAAc,CAACd,CAAAA,CAAO,gBACpCJ,CAAAA,CAAAA,CAMDkB,CAAO,CAAA,IAAA,CAGLL,EACJb,CACAD,CAAAA,CAMN,CAAG,CAAA,CAACS,CAAQ,CAAC,CAGPkB,CAAAA,CAAAA,CAAcT,YACjBU,CAAmB,EAAA,CAClBzC,CAAasB,CAAAA,CAAQ,CASnBK,CAAAA,CAAAA,EAAwBtB,CAAOiB,EAAAA,CAAAA,EAAYf,EAAYe,CAAQ,CAAA,GAAM,CAKtDoB,GAAAA,iBAAAA,CAAkBpB,CAAUnB,CAAAA,CAAAA,CAAWe,CAAM,CAAA,EAG1DyB,CAAQ,CAAA,KAAK,CAIjB,CAAA,CAAA,IAAMC,CAAcC,CAAAA,SAAAA,CAAUvB,CAAUmB,CAAAA,CAAE,EAE1C,OAAO,IAAM,CACXvC,CAAAA,CAAaoB,CAAUnB,CAAAA,CAAAA,CAAWC,CAAYC,CAAAA,CAAG,EACjDuC,CAAY,GACd,CACF,CAAA,CACA,CAACtB,CAAAA,CAAUK,CAAsBtB,CAAAA,CAAAA,CAAKD,EAAYD,CAAS,CAC7D,CAEM2C,CAAAA,CAAAA,CAAQC,oBAEZP,CAAAA,CAAAA,CAAaV,CAAaA,CAAAA,CAAW,CAEjCa,CAAAA,CAAAA,CAAUZ,WAGd,CAAA,MAAOiB,CAAe,CAAA,IAAA,CAAMC,CAAgB,CAAA,KAAO,CACjD,GAAM,CAACb,CAAAA,CAASC,CAAYC,CAAAA,CAAY,CAAIV,CAAAA,CAAAA,CAAiB,QAE7D,GAAI,CAACQ,CACH,CAAA,OAAO,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA,CAI7B,IAAMc,CAAgB,CAAA,CAAC,CAACF,CAAAA,CAGxB,GAAI,CAACE,CAAiBZ,EAAAA,CAAAA,CAAc,CAClC,IAAMN,CAASU,CAAAA,iBAAAA,CAAkBJ,CAAcnC,CAAAA,CAAAA,CAAWkC,CAAU,CAAA,CAEpE,GAAIL,CACF,CAAA,OAAO,OAAQ,CAAA,OAAA,CAAQA,CAAM,CAEjC,CAIA,IAAMmB,EAAcD,CAAgB,CAAA,IAAM,IAAOb,CAAAA,CAAAA,CAAW,WAE5D,CAAA,OAAOE,MAAOH,CAAAA,CAAAA,CAAS,CACrB,GAAGC,CAAAA,CACH,QAAUC,CAAAA,CAAAA,CACV,GAAGW,CAAAA,CACH,UAAA7C,CAAAA,CAAAA,CACA,SAAAD,CAAAA,CAAAA,CACA,SAAAuB,CAAAA,CAAAA,CACA,WAAAyB,CAAAA,CAAAA,CAEA,QAAU,CAAA,UAAA,CACV,YAAa,IACb,CAAA,UAAA,CAAY,CAACd,CAAAA,CAAW,QAC1B,CAAC,CACH,CAAA,CACA,CAAClC,CAAWC,CAAAA,CAAU,CACxB,CAAA,CAEMgD,CAAON,CAAAA,CAAAA,CAAM,IACbO,CAAAA,CAAAA,CAAe,CAACD,CAAQ,EAAA,CAACN,CAAM,CAAA,KAAA,CAC/BQ,CAAaR,CAAAA,CAAAA,CAAM,UACnBS,CAAAA,CAAAA,CACJ,CAAC,CAAClD,CAAAA,GAAQiD,CAAeD,EAAAA,CAAAA,EAAgB1B,CAI3C,CAAA,CAAA,OAAO,CACL,IAAA,CAAAyB,EACA,KAAON,CAAAA,CAAAA,CAAM,KACb,CAAA,MAAA,CAAQA,CAAM,CAAA,MAAA,CACd,OAASA,CAAAA,CAAAA,CAAM,QACf,UAAAQ,CAAAA,CAAAA,CACA,SAAAC,CAAAA,CAAAA,CACA,MAAQT,CAAAA,CAAAA,CAAM,MACd,CAAA,OAAA,CAAAH,CACF,CACF","file":"index.mjs","sourcesContent":["/**\n * @module cache-ref\n *\n * Provides reference counting utilities for cache management in React applications.\n *\n * This module maintains an internal reference count for cache keys, allowing for\n * precise control over when cache entries should be deleted. It exports functions\n * to increment and decrement reference counts, retrieve the current count, and clear\n * all reference counts. When a reference count drops to zero and certain conditions\n * are met, the corresponding cache entry is scheduled for deletion.\n *\n * @see deleteCache\n */\n\nimport { addTimeout, abortRequest, deleteCache } from 'fetchff';\n\nexport const INFINITE_CACHE_TIME = -1;\nexport const DEFAULT_DEDUPE_TIME_MS = 2000;\n\nconst refs = new Map<string, number>();\n\nexport const incrementRef = (key: string | null) => {\n  if (key) {\n    refs.set(key, (refs.get(key) || 0) + 1);\n  }\n};\n\nexport const decrementRef = (\n  key: string | null,\n  cacheTime?: number,\n  dedupeTime?: number,\n  url?: string | null,\n) => {\n  if (!key) {\n    return;\n  }\n\n  const current = getRefCount(key);\n\n  if (!current) {\n    return;\n  }\n\n  const newCount = current - 1;\n\n  // If the current reference count is less than 2, we can consider deleting the global cache entry\n  // The infinite cache time is a special case where we never delete the cache entry unless the reference count drops to zero.\n  // This allows for long-lived cache entries that are only deleted when explicitly no longer needed.\n  if (newCount <= 0) {\n    refs.delete(key);\n\n    if (cacheTime && cacheTime === INFINITE_CACHE_TIME) {\n      // Delay to ensure all operations are complete before deletion\n      addTimeout(\n        'r:' + key,\n        () => {\n          // Abort any ongoing requests associated with this cache key\n          abortRequest(\n            key,\n            new DOMException('Request to ' + url + ' aborted', 'AbortError'),\n          );\n\n          // Check if the reference count is still zero before deleting the cache as it might have been incremented again\n          // This is to ensure that if another increment happens during the timeout, we don't delete the cache prematurely\n          // This is particularly useful in scenarios where multiple components might be using the same cache\n          // entry and we want to avoid unnecessary cache deletions.\n          if (!getRefCount(key)) {\n            deleteCache(key, true);\n          }\n        },\n        dedupeTime ?? DEFAULT_DEDUPE_TIME_MS,\n      );\n    }\n  } else {\n    refs.set(key, newCount);\n  }\n};\n\nexport const getRefCount = (key: string | null): number => {\n  if (!key) {\n    return 0;\n  }\n\n  return refs.get(key) || 0;\n};\n\nexport const getRefs = (): Map<string, number> => {\n  return refs;\n};\n\nexport const clearRefCache = () => {\n  refs.clear();\n};\n","import { useCallback, useSyncExternalStore, useMemo, useRef } from 'react';\nimport {\n  fetchf,\n  subscribe,\n  buildConfig,\n  generateCacheKey,\n  getCachedResponse,\n  getInFlightPromise,\n  getCache,\n} from 'fetchff';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '..';\nimport type { RefetchFunction, UseFetcherResult } from '../types/react-hooks';\n\nimport {\n  decrementRef,\n  DEFAULT_DEDUPE_TIME_MS,\n  getRefCount,\n  incrementRef,\n  INFINITE_CACHE_TIME,\n} from './cache-ref';\n\n// In React, we use a default stale time of 5 minutes (SWR)\nconst DEFAULT_STALE_TIME = 300; // 5 minutes\n\n// Pre-allocate objects to avoid GC pressure\nconst DEFAULT_RESULT = Object.freeze({\n  data: null,\n  error: null,\n  isFetching: false,\n  mutate: () => Promise.resolve(null),\n  config: {},\n  headers: {},\n});\n\nconst FETCHING_RESULT = Object.freeze({\n  ...DEFAULT_RESULT,\n  isFetching: true,\n});\n\nconst DEFAULT_REF = [null, {}, null] as [\n  string | null,\n  RequestConfig,\n  string | null,\n];\n\n// RFC 7231: GET and HEAD are \"safe methods\" with no side effects\nconst SAFE_METHODS = new Set(['GET', 'HEAD', 'get', 'head']);\n\n/**\n * High-performance React hook for fetching data with caching, deduplication, revalidation etc.\n *\n * @template ResponseData - The expected response data type.\n * @template RequestBody - The request payload type.\n * @template QueryParams - The query parameters type.\n * @template PathParams - The URL path parameters type.\n *\n * @param {string|null} url - The endpoint URL to fetch data from. Pass null to skip fetching.\n *   If the URL is null, the hook will not perform any fetch operation.\n *   If the URL is an empty string, it will default to the base URL configured in fetchff.\n *   If the URL is a full URL, it will be used as is.\n * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} [config={}] - fetchff and native fetch compatible configuration.\n *\n * @returns {UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams>} An object containing:\n *   - `data`: The fetched data or `null` if not yet available.\n *   - `error`: Any error encountered during fetching or `null`.\n *   - `isLoading`: Boolean indicating if the request is in progress.\n *   - `mutate`: Function to update the cached data and optionally trigger revalidation.\n *\n * @remarks\n * - Designed for high performance: minimizes unnecessary re-renders and leverages fast cache key generation.\n * - Integrates with a global cache and pub/sub system for efficient state updates across contexts.\n * - Handles automatic revalidation, deduplication, retries, and cache management out of the box.\n *\n * @example\n * ```tsx\n * const { data, error, isLoading, mutate } = useFetcher('/api/data', {\n *   refetchOnFocus: true,\n *   cacheTime: 5,\n *   dedupeTime: 2000,\n *   cacheKey: (config) => `custom-cache-key-${config.url}`,\n * });\n * ```\n */\nexport function useFetcher<\n  ResponseData = DefaultResponse,\n  RequestBody = DefaultPayload,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n>(\n  url: string | null,\n  config: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > = {},\n): UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams> {\n  // Efficient cache key generation based on URL and request parameters.\n  // Optimized for speed: minimizes unnecessary function calls when possible\n  const cacheKey = useMemo(\n    () => (url === null ? null : generateCacheKey(buildConfig(url, config))),\n    [\n      config.cacheKey,\n      url,\n      config.url,\n      config.method,\n      config.headers,\n      config.body,\n      config.params,\n      config.urlPathParams,\n      config.apiUrl,\n      config.baseURL,\n      config.withCredentials,\n      config.credentials,\n    ],\n  );\n  const dedupeTime = config.dedupeTime ?? DEFAULT_DEDUPE_TIME_MS;\n  const cacheTime = config.cacheTime || INFINITE_CACHE_TIME;\n  const staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  // Determine if the fetch should be triggered immediately on mount\n  const shouldTriggerOnMount =\n    config.immediate ?? SAFE_METHODS.has(config.method || 'GET');\n\n  const currentValuesRef = useRef(DEFAULT_REF);\n  currentValuesRef.current = [url, config, cacheKey];\n\n  // Attempt to get the cached response immediately and if not available, return null\n  const getSnapshot = useCallback(() => {\n    const cached = getCache<ResponseData, RequestBody, QueryParams, PathParams>(\n      cacheKey,\n    );\n\n    // Only throw for Suspense if we're in 'reject' mode and have no data\n    if (\n      config.strategy === 'reject' &&\n      cacheKey &&\n      (!cached || (!cached.data.data && !cached.data.error))\n    ) {\n      const pendingPromise = getInFlightPromise(cacheKey, dedupeTime);\n\n      if (pendingPromise) {\n        throw pendingPromise;\n      }\n\n      // If no pending promise but we need to fetch, start fetch and throw the promise\n      if (!cached) {\n        const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n        if (currUrl) {\n          const fetchPromise = fetchf(currUrl, {\n            ...currConfig,\n            cacheKey: currCacheKey,\n            dedupeTime,\n            cacheTime,\n            staleTime,\n            strategy: 'softFail',\n            cacheErrors: true,\n            _isAutoKey: !currConfig.cacheKey,\n          });\n\n          throw fetchPromise;\n        }\n      }\n    }\n\n    if (cached) {\n      return cached.data.isFetching && !config.keepPreviousData\n        ? (FETCHING_RESULT as unknown as FetchResponse<\n            ResponseData,\n            RequestBody,\n            QueryParams,\n            PathParams\n          >)\n        : cached.data;\n    }\n\n    return (shouldTriggerOnMount\n      ? FETCHING_RESULT\n      : DEFAULT_RESULT) as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }, [cacheKey]);\n\n  // Subscribe to cache updates for the specific cache key\n  const doSubscribe = useCallback(\n    (cb: () => void) => {\n      incrementRef(cacheKey);\n\n      // When the component mounts, we want to fetch data if:\n      // 1. URL is provided\n      // 2. shouldTriggerOnMount is true (so the \"immediate\" isn't specified or is true)\n      // 3. There is no cached data\n      // 4. There is no error\n      // 5. There is no ongoing fetch operation\n      const shouldFetch =\n        shouldTriggerOnMount && url && cacheKey && getRefCount(cacheKey) === 1; // Check if no existing refs\n\n      // Initial fetch logic\n      if (shouldFetch) {\n        // Stale-While-Revalidate Pattern: Check for both fresh and stale data\n        const cached = getCachedResponse(cacheKey, cacheTime, config);\n\n        if (!cached) {\n          refetch(false);\n        }\n      }\n\n      const unsubscribe = subscribe(cacheKey, cb);\n\n      return () => {\n        decrementRef(cacheKey, cacheTime, dedupeTime, url);\n        unsubscribe();\n      };\n    },\n    [cacheKey, shouldTriggerOnMount, url, dedupeTime, cacheTime],\n  );\n\n  const state = useSyncExternalStore<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  >(doSubscribe, getSnapshot, getSnapshot);\n\n  const refetch = useCallback<\n    RefetchFunction<ResponseData, RequestBody, QueryParams, PathParams>\n  >(\n    async (forceRefresh = true, requestConfig = {}) => {\n      const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n      if (!currUrl) {\n        return Promise.resolve(null);\n      }\n\n      // Truthy check for forceRefresh to ensure it's a boolean. It is useful in onClick handlers so to avoid additional annonymous function calls.\n      const shouldRefresh = !!forceRefresh;\n\n      // Fast path: check cache first if not forcing refresh\n      if (!shouldRefresh && currCacheKey) {\n        const cached = getCachedResponse(currCacheKey, cacheTime, currConfig);\n\n        if (cached) {\n          return Promise.resolve(cached);\n        }\n      }\n\n      // When manual refetch is triggered, we want to ensure that the cache is busted\n      // This can be disabled by passing `refetch(false)`\n      const cacheBuster = shouldRefresh ? () => true : currConfig.cacheBuster;\n\n      return fetchf(currUrl, {\n        ...currConfig,\n        cacheKey: currCacheKey,\n        ...requestConfig,\n        dedupeTime,\n        cacheTime,\n        staleTime,\n        cacheBuster,\n        // Ensure that errors are handled gracefully and not thrown by default\n        strategy: 'softFail',\n        cacheErrors: true,\n        _isAutoKey: !currConfig.cacheKey,\n      });\n    },\n    [cacheTime, dedupeTime],\n  );\n\n  const data = state.data;\n  const isUnresolved = !data && !state.error;\n  const isFetching = state.isFetching;\n  const isLoading =\n    !!url && (isFetching || (isUnresolved && shouldTriggerOnMount));\n\n  // Consumers always destructure the return value and use the fields directly, so\n  // memoizing the object doesn't change rerender behavior nor improve any performance here\n  return {\n    data,\n    error: state.error,\n    config: state.config,\n    headers: state.headers,\n    isFetching,\n    isLoading,\n    mutate: state.mutate,\n    refetch,\n  };\n}\n"]}