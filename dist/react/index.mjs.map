{"version":3,"sources":["../../src/react/cache-ref.ts","../../src/react/index.ts"],"names":["INFINITE_CACHE_TIME","DEFAULT_DEDUPE_TIME_MS","refs","incrementRef","key","decrementRef","cacheTime","dedupeTime","url","current","getRefCount","newCount","addTimeout","abortRequest","deleteCache","DEFAULT_STALE_TIME","DEFAULT_RESULT","FETCHING_RESULT","DEFAULT_REF","SAFE_METHODS","useFetcher","config","_a","_b","_c","cacheKey","useMemo","generateCacheKey","buildConfig","staleTime","shouldTriggerOnMount","currentValuesRef","useRef","getSnapshot","useCallback","cached","getCache","pendingPromise","getInFlightPromise","currUrl","currConfig","currCacheKey","fetchf","doSubscribe","cb","getCachedResponse","refetch","unsubscribe","subscribe","state","useSyncExternalStore","forceRefresh","requestConfig","shouldRefresh","cacheBuster","data","isUnresolved","isFetching","isFirstFetch","isRefetching"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * @module cache-ref\n *\n * Provides reference counting utilities for cache management in React applications.\n *\n * This module maintains an internal reference count for cache keys, allowing for\n * precise control over when cache entries should be deleted. It exports functions\n * to increment and decrement reference counts, retrieve the current count, and clear\n * all reference counts. When a reference count drops to zero and certain conditions\n * are met, the corresponding cache entry is scheduled for deletion.\n *\n * @see deleteCache\n */\n\nimport { addTimeout, abortRequest, deleteCache } from 'fetchff';\n\nexport const INFINITE_CACHE_TIME = -1;\nexport const DEFAULT_DEDUPE_TIME_MS = 2000;\n\nconst refs = new Map<string, number>();\n\nexport const incrementRef = (key: string | null) => {\n  if (key) {\n    refs.set(key, (refs.get(key) || 0) + 1);\n  }\n};\n\nexport const decrementRef = (\n  key: string | null,\n  cacheTime?: number,\n  dedupeTime?: number,\n  url?: string | null,\n) => {\n  if (!key) {\n    return;\n  }\n\n  const current = getRefCount(key);\n\n  if (!current) {\n    return;\n  }\n\n  const newCount = current - 1;\n\n  // If the current reference count is less than 2, we can consider deleting the global cache entry\n  // The infinite cache time is a special case where we never delete the cache entry unless the reference count drops to zero.\n  // This allows for long-lived cache entries that are only deleted when explicitly no longer needed.\n  if (newCount <= 0) {\n    refs.delete(key);\n\n    if (cacheTime && cacheTime === INFINITE_CACHE_TIME) {\n      // Delay to ensure all operations are complete before deletion\n      addTimeout(\n        'r:' + key,\n        () => {\n          // Abort any ongoing requests associated with this cache key\n          abortRequest(\n            key,\n            new DOMException('Request to ' + url + ' aborted', 'AbortError'),\n          );\n\n          // Check if the reference count is still zero before deleting the cache as it might have been incremented again\n          // This is to ensure that if another increment happens during the timeout, we don't delete the cache prematurely\n          // This is particularly useful in scenarios where multiple components might be using the same cache\n          // entry and we want to avoid unnecessary cache deletions.\n          if (!getRefCount(key)) {\n            deleteCache(key, true);\n          }\n        },\n        dedupeTime ?? DEFAULT_DEDUPE_TIME_MS,\n      );\n    }\n  } else {\n    refs.set(key, newCount);\n  }\n};\n\nexport const getRefCount = (key: string | null): number => {\n  if (!key) {\n    return 0;\n  }\n\n  return refs.get(key) || 0;\n};\n\nexport const getRefs = (): Map<string, number> => {\n  return refs;\n};\n\nexport const clearRefCache = () => {\n  refs.clear();\n};\n","import { useCallback, useSyncExternalStore, useMemo, useRef } from 'react';\nimport {\n  fetchf,\n  subscribe,\n  buildConfig,\n  generateCacheKey,\n  getCachedResponse,\n  getInFlightPromise,\n  getCache,\n} from 'fetchff';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '..';\nimport type { RefetchFunction, UseFetcherResult } from '../types/react-hooks';\n\nimport {\n  decrementRef,\n  DEFAULT_DEDUPE_TIME_MS,\n  getRefCount,\n  incrementRef,\n  INFINITE_CACHE_TIME,\n} from './cache-ref';\n\n// In React, we use a default stale time of 5 minutes (SWR)\nconst DEFAULT_STALE_TIME = 300; // 5 minutes\n\n// Pre-allocate objects to avoid GC pressure\nconst DEFAULT_RESULT = Object.freeze({\n  data: null,\n  error: null,\n  isFetching: false,\n  mutate: () => Promise.resolve(null),\n  config: {},\n  headers: {},\n});\n\nconst FETCHING_RESULT = Object.freeze({\n  ...DEFAULT_RESULT,\n  isFetching: true,\n});\n\nconst DEFAULT_REF = [null, {}, null] as [\n  string | null,\n  RequestConfig,\n  string | null,\n];\n\n// RFC 7231: GET and HEAD are \"safe methods\" with no side effects\nconst SAFE_METHODS = new Set(['GET', 'HEAD', 'get', 'head']);\n\n/**\n * High-performance React hook for fetching data with caching, deduplication, revalidation etc.\n *\n * @template ResponseData - The expected response data type.\n * @template RequestBody - The request payload type.\n * @template QueryParams - The query parameters type.\n * @template PathParams - The URL path parameters type.\n *\n * @param {string|null} url - The endpoint URL to fetch data from. Pass null to skip fetching.\n *   If the URL is null, the hook will not perform any fetch operation.\n *   If the URL is an empty string, it will default to the base URL configured in fetchff.\n *   If the URL is a full URL, it will be used as is.\n * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} [config={}] - fetchff and native fetch compatible configuration.\n *\n * @returns {UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams>} An object containing:\n *   - `data`: The fetched data or `null` if not yet available.\n *   - `error`: Any error encountered during fetching or `null`.\n *   - `isLoading`: Boolean indicating if the request is in progress.\n *   - `mutate`: Function to update the cached data and optionally trigger revalidation.\n *\n * @remarks\n * - Designed for high performance: minimizes unnecessary re-renders and leverages fast cache key generation.\n * - Integrates with a global cache and pub/sub system for efficient state updates across contexts.\n * - Handles automatic revalidation, deduplication, retries, and cache management out of the box.\n *\n * @example\n * ```tsx\n * const { data, error, isLoading, mutate } = useFetcher('/api/data', {\n *   refetchOnFocus: true,\n *   cacheTime: 5,\n *   dedupeTime: 2000,\n *   cacheKey: (config) => `custom-cache-key-${config.url}`,\n * });\n * ```\n */\nexport function useFetcher<\n  ResponseData = DefaultResponse,\n  RequestBody = DefaultPayload,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n>(\n  url: string | null,\n  config: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > = {},\n): UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams> {\n  // Efficient cache key generation based on URL and request parameters.\n  // Optimized for speed: minimizes unnecessary function calls when possible\n  const cacheKey = useMemo(\n    () => (url === null ? null : generateCacheKey(buildConfig(url, config))),\n    [\n      config.cacheKey,\n      url,\n      config.url,\n      config.method,\n      config.headers,\n      config.body,\n      config.params,\n      config.urlPathParams,\n      config.apiUrl,\n      config.baseURL,\n      config.withCredentials,\n      config.credentials,\n    ],\n  );\n  const dedupeTime = config.dedupeTime ?? DEFAULT_DEDUPE_TIME_MS;\n  const cacheTime = config.cacheTime || INFINITE_CACHE_TIME;\n  const staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  // Determine if the fetch should be triggered immediately on mount\n  const shouldTriggerOnMount =\n    config.immediate ?? SAFE_METHODS.has(config.method || 'GET');\n\n  const currentValuesRef = useRef(DEFAULT_REF);\n  currentValuesRef.current = [url, config, cacheKey];\n\n  // Attempt to get the cached response immediately and if not available, return null\n  const getSnapshot = useCallback(() => {\n    const cached = getCache<ResponseData, RequestBody, QueryParams, PathParams>(\n      cacheKey,\n    );\n\n    // Only throw for Suspense if we're in 'reject' mode and have no data\n    if (\n      config.strategy === 'reject' &&\n      cacheKey &&\n      (!cached || (!cached.data.data && !cached.data.error))\n    ) {\n      const pendingPromise = getInFlightPromise(cacheKey, dedupeTime);\n\n      if (pendingPromise) {\n        throw pendingPromise;\n      }\n\n      // If no pending promise but we need to fetch, start fetch and throw the promise\n      if (!cached) {\n        const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n        if (currUrl) {\n          const fetchPromise = fetchf(currUrl, {\n            ...currConfig,\n            cacheKey: currCacheKey,\n            dedupeTime,\n            cacheTime,\n            staleTime,\n            strategy: 'softFail',\n            cacheErrors: true,\n            _isAutoKey: !currConfig.cacheKey,\n          });\n\n          throw fetchPromise;\n        }\n      }\n    }\n\n    if (cached) {\n      return cached.data.isFetching && !config.keepPreviousData\n        ? (FETCHING_RESULT as unknown as FetchResponse<\n            ResponseData,\n            RequestBody,\n            QueryParams,\n            PathParams\n          >)\n        : cached.data;\n    }\n\n    return (shouldTriggerOnMount\n      ? FETCHING_RESULT\n      : DEFAULT_RESULT) as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }, [cacheKey]);\n\n  // Subscribe to cache updates for the specific cache key\n  const doSubscribe = useCallback(\n    (cb: () => void) => {\n      incrementRef(cacheKey);\n\n      // When the component mounts, we want to fetch data if:\n      // 1. URL is provided\n      // 2. shouldTriggerOnMount is true (so the \"immediate\" isn't specified or is true)\n      // 3. There is no cached data\n      // 4. There is no error\n      // 5. There is no ongoing fetch operation\n      const shouldFetch =\n        shouldTriggerOnMount && url && cacheKey && getRefCount(cacheKey) === 1; // Check if no existing refs\n\n      // Initial fetch logic\n      if (shouldFetch) {\n        // Stale-While-Revalidate Pattern: Check for both fresh and stale data\n        const cached = getCachedResponse(cacheKey, cacheTime, config);\n\n        if (!cached) {\n          refetch(false);\n        }\n      }\n\n      const unsubscribe = subscribe(cacheKey, cb);\n\n      return () => {\n        decrementRef(cacheKey, cacheTime, dedupeTime, url);\n        unsubscribe();\n      };\n    },\n    [cacheKey, shouldTriggerOnMount, url, dedupeTime, cacheTime],\n  );\n\n  const state = useSyncExternalStore<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  >(doSubscribe, getSnapshot, getSnapshot);\n\n  const refetch = useCallback<\n    RefetchFunction<ResponseData, RequestBody, QueryParams, PathParams>\n  >(\n    async (forceRefresh = true, requestConfig = {}) => {\n      const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n      if (!currUrl) {\n        return Promise.resolve(null);\n      }\n\n      // Truthy check for forceRefresh to ensure it's a boolean. It is useful in onClick handlers so to avoid additional annonymous function calls.\n      const shouldRefresh = !!forceRefresh;\n\n      // Fast path: check cache first if not forcing refresh\n      if (!shouldRefresh && currCacheKey) {\n        const cached = getCachedResponse(currCacheKey, cacheTime, currConfig);\n\n        if (cached) {\n          return Promise.resolve(cached);\n        }\n      }\n\n      // When manual refetch is triggered, we want to ensure that the cache is busted\n      // This can be disabled by passing `refetch(false)`\n      const cacheBuster = shouldRefresh ? () => true : currConfig.cacheBuster;\n\n      return fetchf(currUrl, {\n        ...currConfig,\n        cacheKey: currCacheKey,\n        ...requestConfig,\n        dedupeTime,\n        cacheTime,\n        staleTime,\n        cacheBuster,\n        // Ensure that errors are handled gracefully and not thrown by default\n        strategy: 'softFail',\n        cacheErrors: true,\n        _isAutoKey: !currConfig.cacheKey,\n      });\n    },\n    [cacheTime, dedupeTime],\n  );\n\n  const data = state.data;\n  const isUnresolved = !data && !state.error;\n\n  // This indicates if the request is in progress or if it is about to start on first mount\n  // It is true when:\n  // - The request is currently ongoing, and it is not background revalidation\n  // - The request is unresolved (no data and no error) and shouldTriggerOnMount\n  //   is true (which means the request is about to start on mount)\n  const isFetching =\n    !!url && (state.isFetching || (isUnresolved && shouldTriggerOnMount));\n  const isFirstFetch = isFetching && isUnresolved;\n  const isRefetching = isFetching && !isUnresolved;\n\n  // Consumers always destructure the return value and use the fields directly, so\n  // memoizing the object doesn't change rerender behavior nor improve any performance here\n  return {\n    data,\n    error: state.error,\n    config: state.config,\n    headers: state.headers,\n    isFirstFetch,\n    isFetching,\n    isLoading: isFetching,\n    isRefetching,\n    isError: state.isError,\n    isSuccess: state.isSuccess,\n    mutate: state.mutate,\n    refetch,\n  };\n}\n"]}