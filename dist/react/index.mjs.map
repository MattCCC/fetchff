{"version":3,"sources":["../../src/react/cache-ref.ts","../../src/react/index.ts"],"names":["INFINITE_CACHE_TIME","DEFAULT_DEDUPE_TIME_MS","refs","incrementRef","key","decrementRef","cacheTime","dedupeTime","url","current","getRefCount","newCount","addTimeout","abortRequest","deleteCache","DEFAULT_STALE_TIME","DEFAULT_RESULT","FETCHING_RESULT","DEFAULT_REF","SAFE_METHODS","useFetcher","config","_a","_b","_c","cacheKey","useMemo","generateCacheKey","buildConfig","staleTime","shouldTriggerOnMount","currentValuesRef","useRef","getSnapshot","useCallback","cached","getCache","pendingPromise","getInFlightPromise","currUrl","currConfig","currCacheKey","fetchf","doSubscribe","cb","getCachedResponse","refetch","unsubscribe","subscribe","state","useSyncExternalStore","forceRefresh","shouldRefresh","cacheBuster","data","isUnresolved","isFetching","isLoading"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * @module cache-ref\n *\n * Provides reference counting utilities for cache management in React applications.\n *\n * This module maintains an internal reference count for cache keys, allowing for\n * precise control over when cache entries should be deleted. It exports functions\n * to increment and decrement reference counts, retrieve the current count, and clear\n * all reference counts. When a reference count drops to zero and certain conditions\n * are met, the corresponding cache entry is scheduled for deletion.\n *\n * @see deleteCache\n */\n\nimport { addTimeout, abortRequest, deleteCache } from 'fetchff';\n\nexport const INFINITE_CACHE_TIME = -1;\nexport const DEFAULT_DEDUPE_TIME_MS = 2000;\n\nconst refs = new Map<string, number>();\n\nexport const incrementRef = (key: string | null) => {\n  if (key) {\n    refs.set(key, (refs.get(key) || 0) + 1);\n  }\n};\n\nexport const decrementRef = (\n  key: string | null,\n  cacheTime?: number,\n  dedupeTime?: number,\n  url?: string | null,\n) => {\n  if (!key) {\n    return;\n  }\n\n  const current = getRefCount(key);\n\n  if (!current) {\n    return;\n  }\n\n  const newCount = current - 1;\n\n  // If the current reference count is less than 2, we can consider deleting the global cache entry\n  // The infinite cache time is a special case where we never delete the cache entry unless the reference count drops to zero.\n  // This allows for long-lived cache entries that are only deleted when explicitly no longer needed.\n  if (newCount <= 0) {\n    refs.delete(key);\n\n    if (cacheTime && cacheTime === INFINITE_CACHE_TIME) {\n      // Delay to ensure all operations are complete before deletion\n      addTimeout(\n        'r:' + key,\n        () => {\n          // Abort any ongoing requests associated with this cache key\n          abortRequest(\n            key,\n            new DOMException('Request to ' + url + ' aborted', 'AbortError'),\n          );\n\n          // Check if the reference count is still zero before deleting the cache as it might have been incremented again\n          // This is to ensure that if another increment happens during the timeout, we don't delete the cache prematurely\n          // This is particularly useful in scenarios where multiple components might be using the same cache\n          // entry and we want to avoid unnecessary cache deletions.\n          if (!getRefCount(key)) {\n            deleteCache(key, true);\n          }\n        },\n        dedupeTime ?? DEFAULT_DEDUPE_TIME_MS,\n      );\n    }\n  } else {\n    refs.set(key, newCount);\n  }\n};\n\nexport const getRefCount = (key: string | null): number => {\n  if (!key) {\n    return 0;\n  }\n\n  return refs.get(key) || 0;\n};\n\nexport const getRefs = (): Map<string, number> => {\n  return refs;\n};\n\nexport const clearRefCache = () => {\n  refs.clear();\n};\n","import { useCallback, useSyncExternalStore, useMemo, useRef } from 'react';\nimport {\n  fetchf,\n  subscribe,\n  buildConfig,\n  generateCacheKey,\n  getCachedResponse,\n  getInFlightPromise,\n  getCache,\n} from 'fetchff';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '..';\nimport type { UseFetcherResult } from '../types/react-hooks';\n\nimport {\n  decrementRef,\n  DEFAULT_DEDUPE_TIME_MS,\n  getRefCount,\n  incrementRef,\n  INFINITE_CACHE_TIME,\n} from './cache-ref';\n\n// In React, we use a default stale time of 5 minutes (SWR)\nconst DEFAULT_STALE_TIME = 300; // 5 minutes\n\n// Pre-allocate objects to avoid GC pressure\nconst DEFAULT_RESULT = Object.freeze({\n  data: null,\n  error: null,\n  isFetching: false,\n  mutate: () => Promise.resolve(null),\n  config: {},\n  headers: {},\n});\n\nconst FETCHING_RESULT = Object.freeze({\n  ...DEFAULT_RESULT,\n  isFetching: true,\n});\n\nconst DEFAULT_REF = [null, {}, null] as [\n  string | null,\n  RequestConfig,\n  string | null,\n];\n\n// RFC 7231: GET and HEAD are \"safe methods\" with no side effects\nconst SAFE_METHODS = new Set(['GET', 'HEAD', 'get', 'head']);\n\n/**\n * High-performance React hook for fetching data with caching, deduplication, revalidation etc.\n *\n * @template ResponseData - The expected response data type.\n * @template RequestBody - The request payload type.\n * @template QueryParams - The query parameters type.\n * @template PathParams - The URL path parameters type.\n *\n * @param {string|null} url - The endpoint URL to fetch data from. Pass null to skip fetching.\n *   If the URL is null, the hook will not perform any fetch operation.\n *   If the URL is an empty string, it will default to the base URL configured in fetchff.\n *   If the URL is a full URL, it will be used as is.\n * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} [config={}] - fetchff and native fetch compatible configuration.\n *\n * @returns {UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams>} An object containing:\n *   - `data`: The fetched data or `null` if not yet available.\n *   - `error`: Any error encountered during fetching or `null`.\n *   - `isLoading`: Boolean indicating if the request is in progress.\n *   - `mutate`: Function to update the cached data and optionally trigger revalidation.\n *\n * @remarks\n * - Designed for high performance: minimizes unnecessary re-renders and leverages fast cache key generation.\n * - Integrates with a global cache and pub/sub system for efficient state updates across contexts.\n * - Handles automatic revalidation, deduplication, retries, and cache management out of the box.\n *\n * @example\n * ```tsx\n * const { data, error, isLoading, mutate } = useFetcher('/api/data', {\n *   refetchOnFocus: true,\n *   cacheTime: 5,\n *   dedupeTime: 2000,\n *   cacheKey: (config) => `custom-cache-key-${config.url}`,\n * });\n * ```\n */\nexport function useFetcher<\n  ResponseData = DefaultResponse,\n  RequestBody = DefaultPayload,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n>(\n  url: string | null,\n  config: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > = {},\n): UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams> {\n  // Efficient cache key generation based on URL and request parameters.\n  // Optimized for speed: minimizes unnecessary function calls when possible\n  const cacheKey = useMemo(\n    () => (url === null ? null : generateCacheKey(buildConfig(url, config))),\n    [\n      config.cacheKey,\n      url,\n      config.url,\n      config.method,\n      config.headers,\n      config.body,\n      config.params,\n      config.urlPathParams,\n      config.apiUrl,\n      config.baseURL,\n      config.withCredentials,\n      config.credentials,\n    ],\n  );\n  const dedupeTime = config.dedupeTime ?? DEFAULT_DEDUPE_TIME_MS;\n  const cacheTime = config.cacheTime || INFINITE_CACHE_TIME;\n  const staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  // Determine if the fetch should be triggered immediately on mount\n  const shouldTriggerOnMount =\n    config.immediate ?? SAFE_METHODS.has(config.method || 'GET');\n\n  const currentValuesRef = useRef(DEFAULT_REF);\n  currentValuesRef.current = [url, config, cacheKey];\n\n  // Attempt to get the cached response immediately and if not available, return null\n  const getSnapshot = useCallback(() => {\n    const cached = getCache<ResponseData, RequestBody, QueryParams, PathParams>(\n      cacheKey,\n    );\n\n    // Only throw for Suspense if we're in 'reject' mode and have no data\n    if (\n      config.strategy === 'reject' &&\n      cacheKey &&\n      (!cached || (!cached.data.data && !cached.data.error))\n    ) {\n      const pendingPromise = getInFlightPromise(cacheKey, dedupeTime);\n\n      if (pendingPromise) {\n        throw pendingPromise;\n      }\n\n      // If no pending promise but we need to fetch, start fetch and throw the promise\n      if (!cached) {\n        const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n        if (currUrl) {\n          const fetchPromise = fetchf(currUrl, {\n            ...currConfig,\n            cacheKey: currCacheKey,\n            dedupeTime,\n            cacheTime,\n            staleTime,\n            strategy: 'softFail',\n            cacheErrors: true,\n            _isAutoKey: !currConfig.cacheKey,\n          });\n\n          throw fetchPromise;\n        }\n      }\n    }\n\n    if (cached) {\n      return cached.data.isFetching && !config.keepPreviousData\n        ? (FETCHING_RESULT as unknown as FetchResponse<\n            ResponseData,\n            RequestBody,\n            QueryParams,\n            PathParams\n          >)\n        : cached.data;\n    }\n\n    return (shouldTriggerOnMount\n      ? FETCHING_RESULT\n      : DEFAULT_RESULT) as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }, [cacheKey]);\n\n  // Subscribe to cache updates for the specific cache key\n  const doSubscribe = useCallback(\n    (cb: () => void) => {\n      incrementRef(cacheKey);\n\n      // When the component mounts, we want to fetch data if:\n      // 1. URL is provided\n      // 2. shouldTriggerOnMount is true (so the \"immediate\" isn't specified or is true)\n      // 3. There is no cached data\n      // 4. There is no error\n      // 5. There is no ongoing fetch operation\n      const shouldFetch =\n        shouldTriggerOnMount && url && cacheKey && getRefCount(cacheKey) === 1; // Check if no existing refs\n\n      // Initial fetch logic\n      if (shouldFetch) {\n        // Stale-While-Revalidate Pattern: Check for both fresh and stale data\n        const cached = getCachedResponse(cacheKey, cacheTime, config);\n\n        if (!cached) {\n          refetch(false);\n        }\n      }\n\n      const unsubscribe = subscribe(cacheKey, cb);\n\n      return () => {\n        decrementRef(cacheKey, cacheTime, dedupeTime, url);\n        unsubscribe();\n      };\n    },\n    [cacheKey, shouldTriggerOnMount, url, dedupeTime, cacheTime],\n  );\n\n  const state = useSyncExternalStore<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  >(doSubscribe, getSnapshot, getSnapshot);\n\n  const refetch = useCallback(\n    async (forceRefresh = true) => {\n      const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n      if (!currUrl) {\n        return Promise.resolve(null);\n      }\n\n      // Truthy check for forceRefresh to ensure it's a boolean. It is useful in onClick handlers so to avoid additional annonymous function calls.\n      const shouldRefresh = !!forceRefresh;\n\n      // Fast path: check cache first if not forcing refresh\n      if (!shouldRefresh && currCacheKey) {\n        const cached = getCachedResponse(currCacheKey, cacheTime, currConfig);\n\n        if (cached) {\n          return Promise.resolve(cached);\n        }\n      }\n\n      // When manual refetch is triggered, we want to ensure that the cache is busted\n      // This can be disabled by passing `refetch(false)`\n      const cacheBuster = shouldRefresh ? () => true : currConfig.cacheBuster;\n\n      return fetchf(currUrl, {\n        ...currConfig,\n        cacheKey: currCacheKey,\n        dedupeTime,\n        cacheTime,\n        staleTime,\n        cacheBuster,\n        // Ensure that errors are handled gracefully and not thrown by default\n        strategy: 'softFail',\n        cacheErrors: true,\n        _isAutoKey: !currConfig.cacheKey,\n      });\n    },\n    [cacheTime, dedupeTime],\n  );\n\n  const data = state.data;\n  const isUnresolved = !data && !state.error;\n  const isFetching = state.isFetching;\n  const isLoading =\n    !!url && (isFetching || (isUnresolved && shouldTriggerOnMount));\n\n  // Consumers always destructure the return value and use the fields directly, so\n  // memoizing the object doesn't change rerender behavior nor improve any performance here\n  return {\n    data,\n    error: state.error,\n    config: state.config,\n    headers: state.headers,\n    isFetching,\n    isLoading,\n    mutate: state.mutate,\n    refetch,\n  };\n}\n"]}