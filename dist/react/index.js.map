{"version":3,"sources":["../../src/react/cache-ref.ts","../../src/react/index.ts"],"names":["INFINITE_CACHE_TIME","DEFAULT_DEDUPE_TIME_MS","refs","incrementRef","key","decrementRef","cacheTime","dedupeTime","url","current","getRefCount","newCount","addTimeout","abortRequest","deleteCache","DEFAULT_STALE_TIME","DEFAULT_RESULT","FETCHING_RESULT","DEFAULT_REF","SAFE_METHODS","useFetcher","config","_a","_b","_c","cacheKey","useMemo","generateCacheKey","buildConfig","staleTime","shouldTriggerOnMount","currentValuesRef","useRef","getSnapshot","useCallback","cached","getCache","pendingPromise","getInFlightPromise","currUrl","currConfig","currCacheKey","fetchf","doSubscribe","cb","getCachedResponse","refetch","unsubscribe","subscribe","state","useSyncExternalStore","forceRefresh","requestConfig","shouldRefresh","cacheBuster","data","isUnresolved","isFetching","isFirstFetch","isRefetching"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module cache-ref\n *\n * Provides reference counting utilities for cache management in React applications.\n *\n * This module maintains an internal reference count for cache keys, allowing for\n * precise control over when cache entries should be deleted. It exports functions\n * to increment and decrement reference counts, retrieve the current count, and clear\n * all reference counts. When a reference count drops to zero and certain conditions\n * are met, the corresponding cache entry is scheduled for deletion.\n *\n * @see deleteCache\n */\n\nimport { addTimeout, abortRequest, deleteCache } from 'fetchff';\n\nexport const INFINITE_CACHE_TIME = -1;\nexport const DEFAULT_DEDUPE_TIME_MS = 2000;\n\nconst refs = new Map<string, number>();\n\nexport const incrementRef = (key: string | null) => {\n  if (key) {\n    refs.set(key, (refs.get(key) || 0) + 1);\n  }\n};\n\nexport const decrementRef = (\n  key: string | null,\n  cacheTime?: number,\n  dedupeTime?: number,\n  url?: string | null,\n) => {\n  if (!key) {\n    return;\n  }\n\n  const current = getRefCount(key);\n\n  if (!current) {\n    return;\n  }\n\n  const newCount = current - 1;\n\n  // If the current reference count is less than 2, we can consider deleting the global cache entry\n  // The infinite cache time is a special case where we never delete the cache entry unless the reference count drops to zero.\n  // This allows for long-lived cache entries that are only deleted when explicitly no longer needed.\n  if (newCount <= 0) {\n    refs.delete(key);\n\n    if (cacheTime && cacheTime === INFINITE_CACHE_TIME) {\n      // Delay to ensure all operations are complete before deletion\n      addTimeout(\n        'r:' + key,\n        () => {\n          // Abort any ongoing requests associated with this cache key\n          abortRequest(\n            key,\n            new DOMException('Request to ' + url + ' aborted', 'AbortError'),\n          );\n\n          // Check if the reference count is still zero before deleting the cache as it might have been incremented again\n          // This is to ensure that if another increment happens during the timeout, we don't delete the cache prematurely\n          // This is particularly useful in scenarios where multiple components might be using the same cache\n          // entry and we want to avoid unnecessary cache deletions.\n          if (!getRefCount(key)) {\n            deleteCache(key, true);\n          }\n        },\n        dedupeTime ?? DEFAULT_DEDUPE_TIME_MS,\n      );\n    }\n  } else {\n    refs.set(key, newCount);\n  }\n};\n\nexport const getRefCount = (key: string | null): number => {\n  if (!key) {\n    return 0;\n  }\n\n  return refs.get(key) || 0;\n};\n\nexport const getRefs = (): Map<string, number> => {\n  return refs;\n};\n\nexport const clearRefCache = () => {\n  refs.clear();\n};\n","import { useCallback, useSyncExternalStore, useMemo, useRef } from 'react';\nimport {\n  fetchf,\n  subscribe,\n  buildConfig,\n  generateCacheKey,\n  getCachedResponse,\n  getInFlightPromise,\n  getCache,\n} from 'fetchff';\nimport type {\n  DefaultParams,\n  DefaultPayload,\n  DefaultResponse,\n  DefaultUrlParams,\n  FetchResponse,\n  RequestConfig,\n} from '..';\nimport type { RefetchFunction, UseFetcherResult } from '../types/react-hooks';\n\nimport {\n  decrementRef,\n  DEFAULT_DEDUPE_TIME_MS,\n  getRefCount,\n  incrementRef,\n  INFINITE_CACHE_TIME,\n} from './cache-ref';\n\n// In React, we use a default stale time of 5 minutes (SWR)\nconst DEFAULT_STALE_TIME = 300; // 5 minutes\n\n// Pre-allocate objects to avoid GC pressure\nconst DEFAULT_RESULT = Object.freeze({\n  data: null,\n  error: null,\n  isFetching: false,\n  mutate: () => Promise.resolve(null),\n  config: {},\n  headers: {},\n});\n\nconst FETCHING_RESULT = Object.freeze({\n  ...DEFAULT_RESULT,\n  isFetching: true,\n});\n\nconst DEFAULT_REF = [null, {}, null] as [\n  string | null,\n  RequestConfig,\n  string | null,\n];\n\n// RFC 7231: GET and HEAD are \"safe methods\" with no side effects\nconst SAFE_METHODS = new Set(['GET', 'HEAD', 'get', 'head']);\n\n/**\n * High-performance React hook for fetching data with caching, deduplication, revalidation etc.\n *\n * @template ResponseData - The expected response data type.\n * @template RequestBody - The request payload type.\n * @template QueryParams - The query parameters type.\n * @template PathParams - The URL path parameters type.\n *\n * @param {string|null} url - The endpoint URL to fetch data from. Pass null to skip fetching.\n *   If the URL is null, the hook will not perform any fetch operation.\n *   If the URL is an empty string, it will default to the base URL configured in fetchff.\n *   If the URL is a full URL, it will be used as is.\n * @param {RequestConfig<ResponseData, QueryParams, PathParams, RequestBody>} [config={}] - fetchff and native fetch compatible configuration.\n *\n * @returns {UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams>} An object containing:\n *   - `data`: The fetched data or `null` if not yet available.\n *   - `error`: Any error encountered during fetching or `null`.\n *   - `isLoading`: Boolean indicating if the request is in progress.\n *   - `mutate`: Function to update the cached data and optionally trigger revalidation.\n *\n * @remarks\n * - Designed for high performance: minimizes unnecessary re-renders and leverages fast cache key generation.\n * - Integrates with a global cache and pub/sub system for efficient state updates across contexts.\n * - Handles automatic revalidation, deduplication, retries, and cache management out of the box.\n *\n * @example\n * ```tsx\n * const { data, error, isLoading, mutate } = useFetcher('/api/data', {\n *   refetchOnFocus: true,\n *   cacheTime: 5,\n *   dedupeTime: 2000,\n *   cacheKey: (config) => `custom-cache-key-${config.url}`,\n * });\n * ```\n */\nexport function useFetcher<\n  ResponseData = DefaultResponse,\n  RequestBody = DefaultPayload,\n  QueryParams = DefaultParams,\n  PathParams = DefaultUrlParams,\n>(\n  url: string | null,\n  config: RequestConfig<\n    ResponseData,\n    QueryParams,\n    PathParams,\n    RequestBody\n  > = {},\n): UseFetcherResult<ResponseData, RequestBody, QueryParams, PathParams> {\n  // Efficient cache key generation based on URL and request parameters.\n  // Optimized for speed: minimizes unnecessary function calls when possible\n  const cacheKey = useMemo(\n    () => (url === null ? null : generateCacheKey(buildConfig(url, config))),\n    [\n      config.cacheKey,\n      url,\n      config.url,\n      config.method,\n      config.headers,\n      config.body,\n      config.params,\n      config.urlPathParams,\n      config.apiUrl,\n      config.baseURL,\n      config.withCredentials,\n      config.credentials,\n    ],\n  );\n  const dedupeTime = config.dedupeTime ?? DEFAULT_DEDUPE_TIME_MS;\n  const cacheTime = config.cacheTime || INFINITE_CACHE_TIME;\n  const staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  // Determine if the fetch should be triggered immediately on mount\n  const shouldTriggerOnMount =\n    config.immediate ?? SAFE_METHODS.has(config.method || 'GET');\n\n  const currentValuesRef = useRef(DEFAULT_REF);\n  currentValuesRef.current = [url, config, cacheKey];\n\n  // Attempt to get the cached response immediately and if not available, return null\n  const getSnapshot = useCallback(() => {\n    const cached = getCache<ResponseData, RequestBody, QueryParams, PathParams>(\n      cacheKey,\n    );\n\n    // Only throw for Suspense if we're in 'reject' mode and have no data\n    if (\n      config.strategy === 'reject' &&\n      cacheKey &&\n      (!cached || (!cached.data.data && !cached.data.error))\n    ) {\n      const pendingPromise = getInFlightPromise(cacheKey, dedupeTime);\n\n      if (pendingPromise) {\n        throw pendingPromise;\n      }\n\n      // If no pending promise but we need to fetch, start fetch and throw the promise\n      if (!cached) {\n        const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n        if (currUrl) {\n          const fetchPromise = fetchf(currUrl, {\n            ...currConfig,\n            cacheKey: currCacheKey,\n            dedupeTime,\n            cacheTime,\n            staleTime,\n            strategy: 'softFail',\n            cacheErrors: true,\n            _isAutoKey: !currConfig.cacheKey,\n          });\n\n          throw fetchPromise;\n        }\n      }\n    }\n\n    if (cached) {\n      return cached.data.isFetching && !config.keepPreviousData\n        ? (FETCHING_RESULT as unknown as FetchResponse<\n            ResponseData,\n            RequestBody,\n            QueryParams,\n            PathParams\n          >)\n        : cached.data;\n    }\n\n    return (shouldTriggerOnMount\n      ? FETCHING_RESULT\n      : DEFAULT_RESULT) as unknown as FetchResponse<\n      ResponseData,\n      RequestBody,\n      QueryParams,\n      PathParams\n    >;\n  }, [cacheKey]);\n\n  // Subscribe to cache updates for the specific cache key\n  const doSubscribe = useCallback(\n    (cb: () => void) => {\n      incrementRef(cacheKey);\n\n      // When the component mounts, we want to fetch data if:\n      // 1. URL is provided\n      // 2. shouldTriggerOnMount is true (so the \"immediate\" isn't specified or is true)\n      // 3. There is no cached data\n      // 4. There is no error\n      // 5. There is no ongoing fetch operation\n      const shouldFetch =\n        shouldTriggerOnMount && url && cacheKey && getRefCount(cacheKey) === 1; // Check if no existing refs\n\n      // Initial fetch logic\n      if (shouldFetch) {\n        // Stale-While-Revalidate Pattern: Check for both fresh and stale data\n        const cached = getCachedResponse(cacheKey, cacheTime, config);\n\n        if (!cached) {\n          refetch(false);\n        }\n      }\n\n      const unsubscribe = subscribe(cacheKey, cb);\n\n      return () => {\n        decrementRef(cacheKey, cacheTime, dedupeTime, url);\n        unsubscribe();\n      };\n    },\n    [cacheKey, shouldTriggerOnMount, url, dedupeTime, cacheTime],\n  );\n\n  const state = useSyncExternalStore<\n    FetchResponse<ResponseData, RequestBody, QueryParams, PathParams>\n  >(doSubscribe, getSnapshot, getSnapshot);\n\n  const refetch = useCallback<\n    RefetchFunction<ResponseData, RequestBody, QueryParams, PathParams>\n  >(\n    async (forceRefresh = true, requestConfig = {}) => {\n      const [currUrl, currConfig, currCacheKey] = currentValuesRef.current;\n\n      if (!currUrl) {\n        return Promise.resolve(null);\n      }\n\n      // Truthy check for forceRefresh to ensure it's a boolean. It is useful in onClick handlers so to avoid additional annonymous function calls.\n      const shouldRefresh = !!forceRefresh;\n\n      // Fast path: check cache first if not forcing refresh\n      if (!shouldRefresh && currCacheKey) {\n        const cached = getCachedResponse(currCacheKey, cacheTime, currConfig);\n\n        if (cached) {\n          return Promise.resolve(cached);\n        }\n      }\n\n      // When manual refetch is triggered, we want to ensure that the cache is busted\n      // This can be disabled by passing `refetch(false)`\n      const cacheBuster = shouldRefresh ? () => true : currConfig.cacheBuster;\n\n      return fetchf(currUrl, {\n        ...currConfig,\n        cacheKey: currCacheKey,\n        ...requestConfig,\n        dedupeTime,\n        cacheTime,\n        staleTime,\n        cacheBuster,\n        // Ensure that errors are handled gracefully and not thrown by default\n        strategy: 'softFail',\n        cacheErrors: true,\n        _isAutoKey: !currConfig.cacheKey,\n      });\n    },\n    [cacheTime, dedupeTime],\n  );\n\n  const data = state.data;\n  const isUnresolved = !data && !state.error;\n\n  // This indicates if the request is in progress or if it is about to start on first mount\n  // It is true when:\n  // - The request is currently ongoing, and it is not background revalidation\n  // - The request is unresolved (no data and no error) and shouldTriggerOnMount\n  //   is true (which means the request is about to start on mount)\n  const isFetching =\n    !!url && (state.isFetching || (isUnresolved && shouldTriggerOnMount));\n  const isFirstFetch = isFetching && isUnresolved;\n  const isRefetching = isFetching && !isUnresolved;\n\n  // Consumers always destructure the return value and use the fields directly, so\n  // memoizing the object doesn't change rerender behavior nor improve any performance here\n  return {\n    data,\n    error: state.error,\n    config: state.config,\n    headers: state.headers,\n    isFirstFetch,\n    isFetching,\n    isLoading: isFetching,\n    isRefetching,\n    isError: state.isError,\n    isSuccess: state.isSuccess,\n    mutate: state.mutate,\n    refetch,\n  };\n}\n"]}